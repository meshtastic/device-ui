#if HAS_TFT // VIEW_320x240

#include "TFTView_320x240.h"
#include "Arduino.h"
#include "DisplayDriver.h"
#include "DisplayDriverFactory.h"
#include "ILog.h"
#include "InputDriver.h"
#include "LoRaPresets.h"
#include "Ringtones.h"
#include "ViewController.h"
#include "images.h"
#include "lv_i18n.h"
#include "ui.h" // this is the ui generated by eez-studio
#include <algorithm>
#include <cstdio>
#include <ctime>
#include <functional>
#include <math.h>

#define CR_REPLACEMENT 0x0C              // dummy to record several lines in a one line textarea
#define THIS TFTView_320x240::instance() // need to use this in all static methods

// children index of nodepanel lv objects (see addNode)
enum NodePanelIdx {
    node_img_idx,
    node_btn_idx,
    node_lbl_idx,
    node_lbs_idx,
    node_bat_idx,
    node_lh_idx,
    node_sig_idx,
    node_pos1_idx,
    node_pos2_idx,
    node_tm1_idx,
    node_tm2_idx
};

TFTView_320x240 *TFTView_320x240::gui = nullptr;
bool TFTView_320x240::advanced_mode = false;

TFTView_320x240 *TFTView_320x240::instance(void)
{
    if (!gui) {
        gui = new TFTView_320x240(nullptr, DisplayDriverFactory::create(320, 240));
    }
    return gui;
}

TFTView_320x240 *TFTView_320x240::instance(const DisplayDriverConfig &cfg)
{
    if (!gui) {
        gui = new TFTView_320x240(&cfg, DisplayDriverFactory::create(cfg));
    }
    return gui;
}

TFTView_320x240::TFTView_320x240(const DisplayDriverConfig *cfg, DisplayDriver *driver)
    : MeshtasticView(cfg, driver, new ViewController), nodesFiltered(0), processingFilter(false), actTime(0), uptime(0)
{
    lastrun1 = lastrun5 = lastrun60 = 0;
    filter.active = false;
    highlight.active = false;
}

void TFTView_320x240::init(IClientBase *client)
{
    ILOG_DEBUG("TFTView_320x240 init...\n");
    ILOG_DEBUG("TFTView_320x240 db size: %d\n", sizeof(TFTView_320x240));
    ILOG_DEBUG("### Images size in flash ###\n");
    uint32_t total_size = 0;
    for (int i = 0; i < sizeof(images) / sizeof(ext_img_desc_t); i++) {
        total_size += images[i].img_dsc->data_size;
        ILOG_DEBUG("    %s: %d\n", images[i].name, images[i].img_dsc->data_size);
    }
    ILOG_DEBUG("================================\n");
    ILOG_DEBUG("### Total size: %d bytes ###\n", total_size);

    MeshtasticView::init(client);
    apply_hotfix();

    time(&lastrun60);
    time(&lastrun5);

    activeMsgContainer = objects.messages_container;
    // setup the two channel label panels with arrays that allow indexing
    channel = {objects.channel_label0, objects.channel_label1, objects.channel_label2, objects.channel_label3,
               objects.channel_label4, objects.channel_label5, objects.channel_label6, objects.channel_label7};
    ch_label = {objects.settings_channel0_label, objects.settings_channel1_label, objects.settings_channel2_label,
                objects.settings_channel3_label, objects.settings_channel4_label, objects.settings_channel5_label,
                objects.settings_channel6_label, objects.settings_channel7_label};

    channelGroup = {nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr};
    ui_set_active(objects.home_button, objects.home_panel, objects.top_panel);
    ui_events_init();

    // load main screen
    lv_screen_load_anim(objects.main_screen, LV_SCR_LOAD_ANIM_NONE, 0, std::min(millis() + 3000, 9000UL), false);

    // re-configuration based on capabilities
    if (!displaydriver->hasLight())
        lv_obj_add_flag(objects.basic_settings_brightness_button, LV_OBJ_FLAG_HIDDEN);

    if (!displaydriver->hasTouch())
        lv_obj_add_flag(objects.basic_settings_calibration_button, LV_OBJ_FLAG_HIDDEN);

#if LV_USE_LIBINPUT
    lv_obj_clear_flag(objects.basic_settings_input_button, LV_OBJ_FLAG_HIDDEN);
#endif

#if defined(USE_I2S_BUZZER)
    lv_obj_clear_flag(objects.basic_settings_alert_button, LV_OBJ_FLAG_HIDDEN);
#else
    lv_obj_add_flag(objects.basic_settings_alert_button, LV_OBJ_FLAG_HIDDEN);
#endif

    setInputGroup();
    setInputButtonLabel();

    // localization
    lv_i18n_init(lv_i18n_language_pack);
    lv_i18n_set_locale("en");
}

/**
 * @brief set active button, panel and top panel
 *
 * @param b button to set active
 * @param p main panel to set active
 * @param tp top panel to set active
 */
void TFTView_320x240::ui_set_active(lv_obj_t *b, lv_obj_t *p, lv_obj_t *tp)
{
    if (activeButton) {
        lv_obj_set_style_border_width(activeButton, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_obj_set_style_bg_img_recolor_opa(activeButton, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    }
    lv_obj_set_style_border_width(b, 3, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_img_recolor(b, lv_color_hex(0x67EA94), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_img_recolor_opa(b, 255, LV_PART_MAIN | LV_STATE_DEFAULT);

    if (activePanel) {
        lv_obj_add_flag(activePanel, LV_OBJ_FLAG_HIDDEN);
        if (activePanel == objects.messages_panel) {
            lv_obj_remove_state(objects.message_input_area, LV_STATE_FOCUSED);
            unreadMessages = 0; // TODO: not all messages may be actually read
            updateUnreadMessages();
        }
    }

    lv_obj_clear_flag(p, LV_OBJ_FLAG_HIDDEN);

    if (tp) {
        if (activeTopPanel) {
            lv_obj_add_flag(activeTopPanel, LV_OBJ_FLAG_HIDDEN);
        }
        lv_obj_clear_flag(tp, LV_OBJ_FLAG_HIDDEN);
        activeTopPanel = tp;
    }

    activeButton = b;
    activePanel = p;
    if (activePanel == objects.messages_panel) {
        lv_group_focus_obj(objects.message_input_area);
    }

    lv_obj_add_flag(objects.keyboard, LV_OBJ_FLAG_HIDDEN);
    lv_obj_add_flag(objects.msg_popup_panel, LV_OBJ_FLAG_HIDDEN);
}

/**
 * @brief fix quirks in the generated ui
 *
 */
void TFTView_320x240::apply_hotfix(void)
{
    lv_obj_move_foreground(objects.keyboard);
}

void TFTView_320x240::ui_events_init(void)
{
    // just a test to implement callback via non-static lambda function
    auto ui_event_HomeButton = [](lv_event_t *e) {
        lv_event_code_t event_code = lv_event_get_code(e);
        if (event_code == LV_EVENT_CLICKED && THIS->activeSettings == eNone) {
            TFTView_320x240 &view = *static_cast<TFTView_320x240 *>(e->user_data);
            view.ui_set_active(objects.home_button, objects.home_panel, objects.top_panel);
        } else if (event_code == LV_EVENT_LONG_PRESSED) {
            // force re-sync with node
            THIS->controller->setConfigRequested(true);
        }
    };

    // main button events
    lv_obj_add_event_cb(objects.home_button, ui_event_HomeButton, LV_EVENT_ALL, this); // uses lambda above
    lv_obj_add_event_cb(objects.nodes_button, this->ui_event_NodesButton, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(objects.groups_button, this->ui_event_GroupsButton, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(objects.messages_button, this->ui_event_MessagesButton, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(objects.map_button, this->ui_event_MapButton, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(objects.settings_button, this->ui_event_SettingsButton, LV_EVENT_ALL, NULL);

    // home buttons
    lv_obj_add_event_cb(objects.home_memory_button, this->ui_event_MemoryButton, LV_EVENT_CLICKED, NULL);

    // node and channel buttons
    lv_obj_add_event_cb(objects.node_button, ui_event_NodeButton, LV_EVENT_ALL, (void *)ownNode);

    // 8 channel buttons
    lv_obj_add_event_cb(objects.channel_button0, ui_event_ChannelButton, LV_EVENT_ALL, (void *)0);
    lv_obj_add_event_cb(objects.channel_button1, ui_event_ChannelButton, LV_EVENT_ALL, (void *)1);
    lv_obj_add_event_cb(objects.channel_button2, ui_event_ChannelButton, LV_EVENT_ALL, (void *)2);
    lv_obj_add_event_cb(objects.channel_button3, ui_event_ChannelButton, LV_EVENT_ALL, (void *)3);
    lv_obj_add_event_cb(objects.channel_button4, ui_event_ChannelButton, LV_EVENT_ALL, (void *)4);
    lv_obj_add_event_cb(objects.channel_button5, ui_event_ChannelButton, LV_EVENT_ALL, (void *)5);
    lv_obj_add_event_cb(objects.channel_button6, ui_event_ChannelButton, LV_EVENT_ALL, (void *)6);
    lv_obj_add_event_cb(objects.channel_button7, ui_event_ChannelButton, LV_EVENT_ALL, (void *)7);

    // new message popup
    lv_obj_add_event_cb(objects.msg_popup_button, this->ui_event_MsgPopupButton, LV_EVENT_CLICKED, NULL);
    lv_obj_add_event_cb(objects.msg_popup_panel, this->ui_event_MsgPopupButton, LV_EVENT_CLICKED, NULL);

    // keyboard
    lv_obj_add_event_cb(objects.keyboard, ui_event_Keyboard, LV_EVENT_CLICKED, this);
    lv_obj_add_event_cb(objects.keyboard_button_0, ui_event_KeyboardButton, LV_EVENT_CLICKED, (void *)0);
    lv_obj_add_event_cb(objects.keyboard_button_1, ui_event_KeyboardButton, LV_EVENT_CLICKED, (void *)1);
    lv_obj_add_event_cb(objects.keyboard_button_2, ui_event_KeyboardButton, LV_EVENT_CLICKED, (void *)2);
    lv_obj_add_event_cb(objects.keyboard_button_3, ui_event_KeyboardButton, LV_EVENT_CLICKED, (void *)3);
    lv_obj_add_event_cb(objects.keyboard_button_4, ui_event_KeyboardButton, LV_EVENT_CLICKED, (void *)4);
    lv_obj_add_event_cb(ui_KeyboardButton5, ui_event_KeyboardButton, LV_EVENT_CLICKED, (void *)5);
    lv_obj_add_event_cb(ui_KeyboardButton6, ui_event_KeyboardButton, LV_EVENT_CLICKED, (void *)6);

    // message text area
    lv_obj_add_event_cb(objects.message_input_area, ui_event_message_ready, LV_EVENT_ALL, NULL);

    // basic settings buttons
    lv_obj_add_event_cb(objects.basic_settings_user_button, ui_event_user_button, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(objects.basic_settings_timeout_button, ui_event_timeout_button, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(objects.basic_settings_role_button, ui_event_role_button, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(objects.basic_settings_region_button, ui_event_region_button, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(objects.basic_settings_modem_preset_button, ui_event_preset_button, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(objects.basic_settings_language_button, ui_event_language_button, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(objects.basic_settings_channel_button, ui_event_channel_button, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(objects.basic_settings_brightness_button, ui_event_brightness_button, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(objects.basic_settings_calibration_button, ui_event_calibration_button, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(objects.basic_settings_input_button, ui_event_input_button, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(objects.basic_settings_alert_button, ui_event_alert_button, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(objects.basic_settings_reset_button, ui_event_reset_button, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(objects.basic_settings_reboot_button, ui_event_reboot_button, LV_EVENT_ALL, NULL);

    lv_obj_add_event_cb(objects.reboot_button, ui_event_device_reboot_button, LV_EVENT_CLICKED, NULL);
    lv_obj_add_event_cb(objects.shutdown_button, ui_event_device_shutdown_button, LV_EVENT_CLICKED, NULL);
    lv_obj_add_event_cb(objects.cancel_reboot_button, ui_event_device_cancel_button, LV_EVENT_CLICKED, NULL);

    // sliders
    lv_obj_add_event_cb(objects.screen_timeout_slider, ui_event_screen_timeout_slider, LV_EVENT_VALUE_CHANGED, NULL);
    lv_obj_add_event_cb(objects.brightness_slider, ui_event_brightness_slider, LV_EVENT_VALUE_CHANGED, NULL);
    lv_obj_add_event_cb(objects.frequency_slot_slider, ui_event_frequency_slot_slider, LV_EVENT_VALUE_CHANGED, NULL);

    // dropdown
    lv_obj_add_event_cb(objects.settings_modem_preset_dropdown, ui_event_modem_preset_dropdown, LV_EVENT_VALUE_CHANGED, NULL);

    // OK / Cancel widget for basic settings dialog
    lv_obj_add_event_cb(objects.obj0__ok_button_w, ui_event_ok, LV_EVENT_CLICKED, 0);
    lv_obj_add_event_cb(objects.obj0__cancel_button_w, ui_event_cancel, LV_EVENT_CLICKED, 0);
    lv_obj_add_event_cb(objects.obj1__ok_button_w, ui_event_ok, LV_EVENT_CLICKED, 0);
    lv_obj_add_event_cb(objects.obj1__cancel_button_w, ui_event_cancel, LV_EVENT_CLICKED, 0);
    lv_obj_add_event_cb(objects.obj2__ok_button_w, ui_event_ok, LV_EVENT_CLICKED, 0);
    lv_obj_add_event_cb(objects.obj2__cancel_button_w, ui_event_cancel, LV_EVENT_CLICKED, 0);
    lv_obj_add_event_cb(objects.obj3__ok_button_w, ui_event_ok, LV_EVENT_CLICKED, 0);
    lv_obj_add_event_cb(objects.obj3__cancel_button_w, ui_event_cancel, LV_EVENT_CLICKED, 0);
    lv_obj_add_event_cb(objects.obj4__ok_button_w, ui_event_ok, LV_EVENT_CLICKED, 0);
    lv_obj_add_event_cb(objects.obj4__cancel_button_w, ui_event_cancel, LV_EVENT_CLICKED, 0);
    lv_obj_add_event_cb(objects.obj5__ok_button_w, ui_event_ok, LV_EVENT_CLICKED, 0);
    lv_obj_add_event_cb(objects.obj5__cancel_button_w, ui_event_cancel, LV_EVENT_CLICKED, 0);
    lv_obj_add_event_cb(objects.obj6__ok_button_w, ui_event_ok, LV_EVENT_CLICKED, 0);
    lv_obj_add_event_cb(objects.obj6__cancel_button_w, ui_event_cancel, LV_EVENT_CLICKED, 0);
    lv_obj_add_event_cb(objects.obj7__ok_button_w, ui_event_ok, LV_EVENT_CLICKED, 0);
    lv_obj_add_event_cb(objects.obj7__cancel_button_w, ui_event_cancel, LV_EVENT_CLICKED, 0);
    lv_obj_add_event_cb(objects.obj8__ok_button_w, ui_event_ok, LV_EVENT_CLICKED, 0);
    lv_obj_add_event_cb(objects.obj8__cancel_button_w, ui_event_cancel, LV_EVENT_CLICKED, 0);
    lv_obj_add_event_cb(objects.obj9__ok_button_w, ui_event_ok, LV_EVENT_CLICKED, 0);
    lv_obj_add_event_cb(objects.obj9__cancel_button_w, ui_event_cancel, LV_EVENT_CLICKED, 0);
    lv_obj_add_event_cb(objects.obj10__ok_button_w, ui_event_ok, LV_EVENT_CLICKED, 0);
    lv_obj_add_event_cb(objects.obj10__cancel_button_w, ui_event_cancel, LV_EVENT_CLICKED, 0);
    lv_obj_add_event_cb(objects.obj11__ok_button_w, ui_event_ok, LV_EVENT_CLICKED, 0);
    lv_obj_add_event_cb(objects.obj11__cancel_button_w, ui_event_cancel, LV_EVENT_CLICKED, 0);

    // modify channel buttons
    lv_obj_add_event_cb(objects.settings_channel0_button, ui_event_modify_channel, LV_EVENT_ALL, (void *)0);
    lv_obj_add_event_cb(objects.settings_channel1_button, ui_event_modify_channel, LV_EVENT_ALL, (void *)1);
    lv_obj_add_event_cb(objects.settings_channel2_button, ui_event_modify_channel, LV_EVENT_ALL, (void *)2);
    lv_obj_add_event_cb(objects.settings_channel3_button, ui_event_modify_channel, LV_EVENT_ALL, (void *)3);
    lv_obj_add_event_cb(objects.settings_channel4_button, ui_event_modify_channel, LV_EVENT_ALL, (void *)4);
    lv_obj_add_event_cb(objects.settings_channel5_button, ui_event_modify_channel, LV_EVENT_ALL, (void *)5);
    lv_obj_add_event_cb(objects.settings_channel6_button, ui_event_modify_channel, LV_EVENT_ALL, (void *)6);
    lv_obj_add_event_cb(objects.settings_channel7_button, ui_event_modify_channel, LV_EVENT_ALL, (void *)7);
    // delete channel button
    lv_obj_add_event_cb(objects.settings_modify_trash_button, ui_event_delete_channel, LV_EVENT_CLICKED, NULL);

    // screen
    lv_obj_add_event_cb(objects.calibration_screen, ui_event_calibration_screen_loaded, LV_EVENT_SCREEN_LOADED, (void *)7);
}

#if 0 // defined above as lambda function for tests
void TDeckGUI::ui_event_HomeButton(lv_event_t * e) {
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED) {
        TDeckGUI::instance()->ui_set_active(objects.home_button, objects.home_panel, objects.top_panel);
    }
}
#endif

void TFTView_320x240::ui_event_NodesButton(lv_event_t *e)
{
    static bool ignoreClicked = false;
    static bool filterNeedsUpdate = false;
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED && THIS->activeSettings == eNone) {
        if (ignoreClicked) { // prevent long press to enter this setting
            ignoreClicked = false;
            return;
        }
        THIS->ui_set_active(objects.nodes_button, objects.nodes_panel, objects.top_nodes_panel);
        if (filterNeedsUpdate) {
            THIS->updateNodesFiltered(true);
            THIS->updateNodesStatus();
            filterNeedsUpdate = false;
        }
    } else if (event_code == LV_EVENT_LONG_PRESSED) {
        filterNeedsUpdate = true;
        ignoreClicked = true;
        THIS->ui_set_active(objects.nodes_button, ui_NodesOptionsPanel, objects.top_node_options_panel);
    }
}

void TFTView_320x240::ui_event_NodeButton(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED) {
        uint32_t nodeNum = (unsigned long)e->user_data;
        if (!nodeNum) // event-handler for own node has value 0 in user_data
            nodeNum = THIS->ownNode;
        static lv_obj_t *currentPanel = nullptr;
        lv_obj_t *panel = THIS->nodes[nodeNum];
        if (currentPanel) {
            // create animation to shrink other panel
            lv_anim_t a;
            int32_t height = lv_obj_get_height(currentPanel);
            lv_anim_init(&a);
            lv_anim_set_var(&a, currentPanel);
            lv_anim_set_values(&a, height, 132 - height);
            lv_anim_set_duration(&a, 200);
            lv_anim_set_exec_cb(&a, ui_anim_node_panel_cb);
            lv_anim_set_path_cb(&a, lv_anim_path_linear);
            lv_anim_start(&a);
        }
        if (panel != currentPanel) {
            // create animation to enlarge node panel
            lv_anim_t a;
            int32_t height = lv_obj_get_height(panel);
            lv_anim_init(&a);
            lv_anim_set_var(&a, panel);
            lv_anim_set_values(&a, height, 132 - height);
            lv_anim_set_duration(&a, 200);
            lv_anim_set_exec_cb(&a, ui_anim_node_panel_cb);
            lv_anim_set_path_cb(&a, lv_anim_path_linear);
            lv_anim_start(&a);
            currentPanel = panel;
        } else
            currentPanel = nullptr;
    } else if (event_code == LV_EVENT_LONG_PRESSED) {
        //  set color and text of clicked node
        uint32_t nodeNum = (unsigned long)e->user_data;
        if (nodeNum != THIS->ownNode)
            THIS->showMessages(nodeNum);
    }
}

void TFTView_320x240::ui_event_GroupsButton(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED && THIS->activeSettings == eNone) {
        THIS->ui_set_active(objects.groups_button, objects.groups_panel, objects.top_groups_panel);
    }
}

void TFTView_320x240::ui_event_ChannelButton(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED && THIS->activeSettings == eNone) {
        uint8_t ch = (uint8_t)(unsigned long)e->user_data;
        if (THIS->db.channel[ch].role != meshtastic_Channel_Role_DISABLED)
            THIS->showMessages(ch);
    } else {
        // TODO: click on unset channel should popup config screen
    }
}

void TFTView_320x240::ui_event_MessagesButton(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED && THIS->activeSettings == eNone) {
        THIS->ui_set_active(objects.messages_button, objects.chats_panel, objects.top_chats_panel);
    }
}

void TFTView_320x240::ui_event_MapButton(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED && THIS->activeSettings == eNone) {
        THIS->ui_set_active(objects.map_button, objects.map_panel, objects.top_map_panel);
    }
}

void TFTView_320x240::ui_event_SettingsButton(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED && THIS->activeSettings == eNone) {
        THIS->ui_set_active(objects.settings_button, objects.basic_settings_panel, objects.top_settings_panel);
    } else if (event_code == LV_EVENT_LONG_PRESSED && !advanced_mode && THIS->activeSettings == eNone) {
        advanced_mode = !advanced_mode;
    } else if (event_code == LV_EVENT_LONG_PRESSED && advanced_mode && THIS->activeSettings == eNone) {
        advanced_mode = !advanced_mode;
        THIS->ui_set_active(objects.settings_button, ui_AdvancedSettingsPanel, objects.top_advanced_settings_panel);
    }
}

void TFTView_320x240::ui_event_ChatButton(lv_event_t *e)
{
    static bool ignoreClicked = false;
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t *target = lv_event_get_target_obj(e);
    if (event_code == LV_EVENT_LONG_PRESSED) {
        ignoreClicked = true;
        lv_obj_t *delBtn = target->LV_OBJ_IDX(1);
        lv_obj_clear_flag(delBtn, LV_OBJ_FLAG_HIDDEN);
    } else if (event_code == LV_EVENT_DEFOCUSED || event_code == LV_EVENT_LEAVE) {
        lv_obj_t *delBtn = target->LV_OBJ_IDX(1);
        lv_obj_add_flag(delBtn, LV_OBJ_FLAG_HIDDEN);
    } else if (event_code == LV_EVENT_CLICKED) {
        if (ignoreClicked) { // prevent long press to enter this setting
            ignoreClicked = false;
            return;
        }
        lv_obj_set_style_border_color(target, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);

        uint32_t channelOrNode = (unsigned long)e->user_data;
        if (channelOrNode < c_max_channels) {
            uint8_t ch = (uint8_t)channelOrNode;
            THIS->showMessages(ch);
            THIS->ui_set_active(objects.messages_button, objects.messages_panel, objects.top_group_chat_panel);
        } else {
            uint32_t nodeNum = channelOrNode;
            THIS->showMessages(nodeNum);
            THIS->ui_set_active(objects.messages_button, objects.messages_panel, objects.top_messages_panel);
        }
    }
}

/**
 * @brief Del button pressed, handle deletion or clearance of chat and messages panel
 *
 * @param e
 */
void TFTView_320x240::ui_event_ChatDelButton(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED) {
        lv_obj_t *target = lv_event_get_target_obj(e);
        lv_obj_add_flag(target, LV_OBJ_FLAG_HIDDEN);

        uint32_t channelOrNode = (unsigned long)e->user_data;
        if (channelOrNode < c_max_channels) {
            uint8_t ch = (uint8_t)channelOrNode;
            lv_obj_delete_delayed(THIS->chats[ch], 500);
            lv_obj_del(THIS->channelGroup[ch]);
            THIS->channelGroup[ch] = nullptr;
            THIS->chats.erase(ch);
        } else {
            uint32_t nodeNum = channelOrNode;
            lv_obj_delete_delayed(THIS->chats[nodeNum], 500);
            lv_obj_del(THIS->messages[nodeNum]);
            THIS->messages.erase(nodeNum);
            THIS->chats.erase(nodeNum);
            THIS->applyNodesFilter(nodeNum);
        }
        THIS->activeMsgContainer = objects.messages_container;
        THIS->updateActiveChats();
    }
}

/**
 * @brief hide msgPopupPanel on touch; goto message on button press
 *
 */
void TFTView_320x240::ui_event_MsgPopupButton(lv_event_t *e)
{
    lv_obj_t *target = lv_event_get_target_obj(e);
    lv_event_code_t event_code = lv_event_get_code(e);
    if (target == objects.msg_popup_panel) {
        if (event_code == LV_EVENT_PRESSED) {
            THIS->hideMessagePopup();
        }
    } else { // msg button was clicked
        if (event_code == LV_EVENT_CLICKED) {
            uint32_t channelOrNode = (unsigned long)objects.msg_popup_button->user_data;
            if (channelOrNode < c_max_channels) {
                uint8_t ch = (uint8_t)channelOrNode;
                THIS->showMessages(ch);
            } else {
                uint32_t nodeNum = channelOrNode;
                THIS->showMessages(nodeNum);
            }
        }
    }
}

void TFTView_320x240::ui_event_MemoryButton(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED) {
        // toggle memory display updates
        uint32_t toggle = (unsigned long)objects.home_memory_button->user_data;
        objects.home_memory_button->user_data = (void *)(1 - toggle);
        lv_obj_set_style_bg_image_recolor(objects.home_memory_button,
                                          toggle ? lv_color_hex(0xff606060) : lv_color_hex(0xffffffff),
                                          LV_PART_MAIN | LV_STATE_DEFAULT);
    }
}

void TFTView_320x240::ui_event_KeyboardButton(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED) {
        uint32_t keyBtnIdx = (unsigned long)e->user_data;
        switch (keyBtnIdx) {
        case 0:
            THIS->showKeyboard(objects.message_input_area);
            break;
        case 1:
            THIS->showKeyboard(objects.settings_user_short_textarea);
            break;
        case 2:
            THIS->showKeyboard(objects.settings_user_long_textarea);
            break;
        case 3:
            THIS->showKeyboard(objects.settings_modify_channel_name_textarea);
            break;
        case 4:
            THIS->showKeyboard(objects.settings_modify_channel_psk_textarea);
            break;
        case 5:
            THIS->showKeyboard(ui_NodesFilterNameArea);
            lv_obj_add_state(ui_NodesFilterNameArea, LV_STATE_FOCUSED);
            break;
        case 6:
            THIS->showKeyboard(ui_NodesHLNameArea);
            lv_obj_add_state(ui_NodesHLNameArea, LV_STATE_FOCUSED);
            break;
        default:
            ILOG_ERROR("missing keyboard <-> textarea assignment\n");
        }
        lv_obj_has_flag(objects.keyboard, LV_OBJ_FLAG_HIDDEN) ? lv_obj_remove_flag(objects.keyboard, LV_OBJ_FLAG_HIDDEN)
                                                              : lv_obj_add_flag(objects.keyboard, LV_OBJ_FLAG_HIDDEN);
    }
}

void TFTView_320x240::ui_event_Keyboard(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED) {
        lv_obj_t *kb = lv_event_get_target_obj(e);
        uint32_t btn_id = lv_keyboard_get_selected_button(kb);

        switch (btn_id) {
        case 22: { // enter (filtered out by one-liner text input area, so we replace it)
            lv_obj_t *ta = lv_keyboard_get_textarea(kb);
            lv_textarea_add_char(ta, ' ');
            lv_textarea_add_char(ta, CR_REPLACEMENT);
            break;
        }
        case 35: { // keyboard
            lv_keyboard_set_popovers(objects.keyboard, !lv_buttonmatrix_get_popovers(kb));
            break;
        }
        case 36: { // left
            break;
        }
        case 38: { // right
            break;
        }
        case 39: { // checkmark
            lv_obj_add_flag(kb, LV_OBJ_FLAG_HIDDEN);
            break;
        }
        default:
            break;
            // const char *txt = lv_keyboard_get_button_text(kb, btn_id);
        }
    }
}

void TFTView_320x240::ui_event_message_ready(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_READY) {
        char *txt = (char *)lv_textarea_get_text(objects.message_input_area);
        uint32_t len = strlen(txt);
        if (len) {
            if (txt[len - 1] == ' ') { // use space+return combo to start new line in same message
                lv_textarea_add_char(objects.message_input_area, CR_REPLACEMENT);
            } else {
                THIS->handleAddMessage(txt);
                lv_textarea_set_text(objects.message_input_area, "");
            }
        }
    }
}

// basic settings buttons

void TFTView_320x240::ui_event_user_button(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED && THIS->activeSettings == eNone) {
        lv_textarea_set_text(objects.settings_user_short_textarea, THIS->db.short_name);
        lv_textarea_set_text(objects.settings_user_long_textarea, THIS->db.long_name);
        lv_obj_clear_flag(objects.settings_username_panel, LV_OBJ_FLAG_HIDDEN);
        THIS->activeSettings = eUsername;
    }
}

void TFTView_320x240::ui_event_role_button(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED && THIS->activeSettings == eNone && THIS->db.config.has_device) {
        lv_dropdown_set_selected(objects.settings_device_role_dropdown, THIS->db.config.device.role);
        lv_obj_clear_flag(objects.settings_device_role_panel, LV_OBJ_FLAG_HIDDEN);
        THIS->activeSettings = eDeviceRole;
    }
}

void TFTView_320x240::ui_event_region_button(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED && THIS->activeSettings == eNone && THIS->db.config.has_lora) {
        THIS->activeSettings = eRegion;
        lv_dropdown_set_selected(objects.settings_region_dropdown, THIS->db.config.lora.region - 1);
        lv_obj_clear_flag(objects.settings_region_panel, LV_OBJ_FLAG_HIDDEN);
    }
}

void TFTView_320x240::ui_event_preset_button(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED && THIS->activeSettings == eNone && THIS->db.config.has_lora) {
        THIS->activeSettings = eModemPreset;
        lv_dropdown_set_selected(objects.settings_modem_preset_dropdown, THIS->db.config.lora.modem_preset);

        char buf[40];
        sprintf(buf, "FrequencySlot: %d (%.2f MHz)", THIS->db.config.lora.channel_num,
                LoRaPresets::getRadioFreq(THIS->db.config.lora.region, THIS->db.config.lora.modem_preset,
                                          THIS->db.config.lora.channel_num));
        lv_label_set_text(objects.frequency_slot_label, buf);

        uint32_t numChannels = LoRaPresets::getNumChannels(THIS->db.config.lora.region, THIS->db.config.lora.modem_preset);
        lv_slider_set_range(objects.frequency_slot_slider, 1, numChannels);
        lv_slider_set_value(objects.frequency_slot_slider, THIS->db.config.lora.channel_num, LV_ANIM_OFF);

        lv_obj_clear_flag(objects.settings_modem_preset_panel, LV_OBJ_FLAG_HIDDEN);
    }
}

void TFTView_320x240::ui_event_language_button(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED && THIS->activeSettings == eNone) {
        // TODO: set actual value for dropdown
        lv_obj_clear_flag(objects.settings_language_panel, LV_OBJ_FLAG_HIDDEN);
        THIS->activeSettings = eLanguage;
    }
}

void TFTView_320x240::ui_event_channel_button(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED && THIS->activeSettings == eNone) {
        // primary channel is not necessarily channel[0], setup ui with primary on top
        int pos = 1;
        for (int i = 0; i < c_max_channels; i++) {
            if (THIS->db.channel[i].has_settings && THIS->db.channel[i].role != meshtastic_Channel_Role_DISABLED) {
                if (THIS->db.channel[i].role == meshtastic_Channel_Role_PRIMARY) {
                    THIS->ch_label[0]->user_data = (void *)i;
                    lv_label_set_text(THIS->ch_label[0], THIS->db.channel[i].settings.name);
                } else {
                    THIS->ch_label[pos]->user_data = (void *)i;
                    lv_label_set_text(THIS->ch_label[pos++], THIS->db.channel[i].settings.name);
                }
            }
        }
        for (int i = pos; i < c_max_channels; i++) {
            THIS->ch_label[i]->user_data = (void *)-1;
            lv_label_set_text(THIS->ch_label[i], "<unset>");
        }
        lv_obj_clear_flag(objects.settings_channel_panel, LV_OBJ_FLAG_HIDDEN);
        THIS->activeSettings = eChannel;

        // create scratch channels to store temporary changes until cancelled or applied
        THIS->channel_scratch = new meshtastic_Channel[c_max_channels];
        for (int i = 0; i < c_max_channels; i++) {
            THIS->channel_scratch[i] = THIS->db.channel[i];
        }
    }
}

void TFTView_320x240::ui_event_brightness_button(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED && THIS->activeSettings == eNone) {
        int32_t brightness = THIS->displaydriver->getBrightness() * 100 / 255;
        char buf[32];
        lv_snprintf(buf, sizeof(buf), "Screen Brightness: %d%%", brightness);
        lv_label_set_text(objects.basic_settings_brightness_label, buf);
        lv_slider_set_value(objects.brightness_slider, brightness, LV_ANIM_OFF);
        objects.brightness_slider->user_data = (void *)brightness; // store old value
        lv_obj_clear_flag(objects.settings_brightness_panel, LV_OBJ_FLAG_HIDDEN);
        THIS->activeSettings = eScreenBrightness;
    }
}

void TFTView_320x240::ui_event_calibration_button(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED) {
        lv_screen_load_anim(objects.calibration_screen, LV_SCR_LOAD_ANIM_NONE, 0, 0, false);
    }
}

void TFTView_320x240::ui_event_timeout_button(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED && THIS->activeSettings == eNone) {
        int32_t timeout = THIS->displaydriver->getScreenTimeout();
        lv_obj_clear_flag(objects.settings_screen_timeout_panel, LV_OBJ_FLAG_HIDDEN);
        lv_slider_set_value(objects.screen_timeout_slider, timeout, LV_ANIM_OFF);
        THIS->activeSettings = eScreenTimeout;
    }
}

void TFTView_320x240::ui_event_input_button(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED && THIS->activeSettings == eNone) {
        std::vector<std::string> ptr_events = THIS->inputdriver->getPointerDevices();
        std::string ptr_dropdown = "none";
        for (std::string &s : ptr_events) {
            ptr_dropdown += '\n' + s;
        }
        lv_dropdown_set_options(objects.settings_mouse_input_dropdown, ptr_dropdown.c_str());
        std::string current_ptr = THIS->inputdriver->getCurrentPointerDevice();
        uint32_t ptrOption = lv_dropdown_get_option_index(objects.settings_mouse_input_dropdown, current_ptr.c_str());
        lv_dropdown_set_selected(objects.settings_mouse_input_dropdown, ptrOption);

        std::vector<std::string> kbd_events = THIS->inputdriver->getKeyboardDevices();
        std::string kbd_dropdown = "none";
        for (std::string &s : kbd_events) {
            kbd_dropdown += '\n' + s;
        }
        lv_dropdown_set_options(objects.settings_keyboard_input_dropdown, kbd_dropdown.c_str());
        std::string current_kbd = THIS->inputdriver->getCurrentKeyboardDevice();
        uint32_t kbdOption = lv_dropdown_get_option_index(objects.settings_keyboard_input_dropdown, current_kbd.c_str());
        lv_dropdown_set_selected(objects.settings_keyboard_input_dropdown, kbdOption);

        lv_dropdown_get_selected_str(objects.settings_keyboard_input_dropdown, THIS->old_val1_scratch, sizeof(old_val1_scratch));
        lv_dropdown_get_selected_str(objects.settings_mouse_input_dropdown, THIS->old_val2_scratch, sizeof(old_val2_scratch));

        lv_obj_clear_flag(objects.settings_input_control_panel, LV_OBJ_FLAG_HIDDEN);
        THIS->activeSettings = eInputControl;
    }
}

void TFTView_320x240::ui_event_alert_button(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED && THIS->activeSettings == eNone && THIS->db.module_config.has_external_notification) {
        bool alert_enabled = THIS->db.module_config.external_notification.alert_message_buzzer &&
                             THIS->db.module_config.external_notification.enabled;
        if (alert_enabled) {
            lv_obj_add_state(objects.settings_alert_buzzer_switch, LV_STATE_CHECKED);
        } else {
            lv_obj_remove_state(objects.settings_alert_buzzer_switch, LV_STATE_CHECKED);
        }
        // populate dropdown
        if (lv_dropdown_get_option_count(objects.settings_ringtone_dropdown) <= 1) {
            for (int i = 1; i < numRingtones; i++) {
                lv_dropdown_add_option(objects.settings_ringtone_dropdown, ringtone[i].name, i);
            }
        }

        // TODO select option according rttl string
        // TODO need to fetch and store rttl string from radio
        lv_obj_clear_flag(objects.settings_alert_buzzer_panel, LV_OBJ_FLAG_HIDDEN);
        THIS->activeSettings = eAlertBuzzer;
    }
}

// configuration reset
void TFTView_320x240::ui_event_reset_button(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED && THIS->activeSettings == eNone) {
        lv_obj_clear_flag(objects.settings_reset_panel, LV_OBJ_FLAG_HIDDEN);
        THIS->activeSettings = eReset;
    }
}

// reboot / shutdown
void TFTView_320x240::ui_event_reboot_button(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED && THIS->activeSettings == eNone) {
        lv_screen_load_anim(objects.boot_screen, LV_SCR_LOAD_ANIM_FADE_IN, 1000, 0, false);
        lv_obj_clear_flag(objects.reboot_panel, LV_OBJ_FLAG_HIDDEN);
        THIS->activeSettings = eReboot;
    }
}

void TFTView_320x240::ui_event_device_reboot_button(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED) {
        THIS->controller->requestReboot(5, THIS->ownNode);
        lv_screen_load_anim(objects.blank_screen, LV_SCR_LOAD_ANIM_FADE_OUT, 4000, 1000, false);
        lv_obj_add_flag(objects.reboot_panel, LV_OBJ_FLAG_HIDDEN);
    }
}

void TFTView_320x240::ui_event_device_shutdown_button(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED) {
        THIS->controller->requestShutdown(5, THIS->ownNode);
        lv_screen_load_anim(objects.blank_screen, LV_SCR_LOAD_ANIM_FADE_OUT, 4000, 1000, false);
        lv_obj_add_flag(objects.reboot_panel, LV_OBJ_FLAG_HIDDEN);
    }
}

void TFTView_320x240::ui_event_device_cancel_button(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED) {
        lv_screen_load_anim(objects.main_screen, LV_SCR_LOAD_ANIM_NONE, 0, 0, false);
        lv_obj_add_flag(objects.reboot_panel, LV_OBJ_FLAG_HIDDEN);
        THIS->activeSettings = eNone;
    }
}

void TFTView_320x240::ui_event_modify_channel(lv_event_t *e)
{
    static bool ignoreClicked = false;
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED && THIS->activeSettings == eChannel) {
        if (ignoreClicked) { // prevent long press to enter this setting
            ignoreClicked = false;
            return;
        }
        uint32_t btn_id = (unsigned long)e->user_data;
        int8_t ch = (signed long)THIS->ch_label[btn_id]->user_data;
        if (ch != -1) {
            meshtastic_ChannelSettings_psk_t &psk = THIS->channel_scratch[ch].settings.psk;
            std::string base64 = THIS->pskToBase64(psk);
            lv_textarea_set_text(objects.settings_modify_channel_psk_textarea, base64.c_str());
            lv_textarea_set_text(objects.settings_modify_channel_name_textarea, THIS->channel_scratch[ch].settings.name);
            objects.settings_modify_channel_name_textarea->user_data = (void *)btn_id;
        } else {
            for (int i = 0; i < c_max_channels; i++) {
                if (THIS->channel_scratch[i].role == meshtastic_Channel_Role_DISABLED) {
                    // the first created channel is PRIMARY
                    bool found = false;
                    for (int j = 0; j < c_max_channels; j++) {
                        if (THIS->channel_scratch[j].role == meshtastic_Channel_Role_PRIMARY) {
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        THIS->channel_scratch[i].role = meshtastic_Channel_Role_PRIMARY;
                        if (i == 0) {
                            btn_id = 0; // place on top
                        } else {
                            // FIXME: swap ids as in long press
                            ILOG_ERROR("node does not have primary channel!\n");
                        }
                    } else
                        THIS->channel_scratch[i].role = meshtastic_Channel_Role_SECONDARY;

                    lv_textarea_set_text(objects.settings_modify_channel_psk_textarea, "");
                    lv_textarea_set_text(objects.settings_modify_channel_name_textarea, "");
                    THIS->ch_label[btn_id]->user_data = (void *)i;
                    objects.settings_modify_channel_name_textarea->user_data = (void *)btn_id;
                    break;
                }
            }
        }
        lv_obj_add_state(objects.settings_channel_panel, LV_STATE_DISABLED);
        lv_obj_clear_flag(objects.settings_modify_channel_panel, LV_OBJ_FLAG_HIDDEN);
        THIS->activeSettings = eModifyChannel;
    } else if (event_code == LV_EVENT_LONG_PRESSED && THIS->activeSettings == eChannel) {
        ignoreClicked = true;
        // make channel primary on long press; swap with current primary (role, id and name)
        uint8_t btn_id = (uint8_t)(unsigned long)e->user_data;
        int8_t ch = (signed long)THIS->ch_label[btn_id]->user_data;
        if (btn_id != 0 && ch != -1) {
            int32_t primary_id = (signed long)THIS->ch_label[0]->user_data;
            THIS->channel_scratch[primary_id].role = meshtastic_Channel_Role_SECONDARY;
            THIS->channel_scratch[ch].role = meshtastic_Channel_Role_PRIMARY;
            THIS->ch_label[0]->user_data = (void *)(uint32_t)ch;
            THIS->ch_label[btn_id]->user_data = (void *)primary_id;
            lv_label_set_text(THIS->ch_label[0], THIS->channel_scratch[ch].settings.name);
            lv_label_set_text(THIS->ch_label[btn_id], THIS->channel_scratch[primary_id].settings.name);
        }
    }
}

void TFTView_320x240::ui_event_delete_channel(lv_event_t *e)
{
    lv_textarea_set_text(objects.settings_modify_channel_psk_textarea, "");
    lv_textarea_set_text(objects.settings_modify_channel_name_textarea, "");
}

void TFTView_320x240::ui_event_calibration_screen_loaded(lv_event_t *e)
{
    bool done = THIS->displaydriver->calibrate();
    char buf[32];
    lv_snprintf(buf, sizeof(buf), _("Screen Calibration: %s"), done ? _("done") : _("default"));
    lv_label_set_text(objects.basic_settings_calibration_label, buf);
    lv_screen_load_anim(objects.main_screen, LV_SCR_LOAD_ANIM_FADE_ON, 200, 0, false);
}

/**
 * @brief User widget OK button handling
 *
 * @param e
 */
void TFTView_320x240::ui_event_ok(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED) {
        switch (THIS->activeSettings) {
        case eUsername: {
            char buf[30];
            const char *userShort = lv_textarea_get_text(objects.settings_user_short_textarea);
            const char *userLong = lv_textarea_get_text(objects.settings_user_long_textarea);
            lv_snprintf(buf, sizeof(buf), _("User name: %s"), userShort);
            lv_label_set_text(objects.basic_settings_user_label, buf);
            lv_label_set_text(objects.user_name_short_label, userShort);
            lv_label_set_text(objects.user_name_label, userLong);
            strcpy(THIS->db.short_name, userShort);
            strcpy(THIS->db.long_name, userLong);
            meshtastic_User user; // TODO: don't overwrite is_licensed
            strcpy(user.short_name, userShort);
            strcpy(user.long_name, userLong);
            THIS->controller->sendConfig(user, THIS->ownNode);
            THIS->notifyReboot(true);
            lv_obj_add_flag(objects.settings_username_panel, LV_OBJ_FLAG_HIDDEN);
            break;
        }
        case eDeviceRole: {
            char buf1[10], buf2[30];
            lv_dropdown_get_selected_str(objects.settings_device_role_dropdown, buf1, sizeof(buf1));
            lv_snprintf(buf2, sizeof(buf2), _("Device Role: %s"), buf1);
            lv_label_set_text(objects.basic_settings_role_label, buf2);

            meshtastic_Config_DeviceConfig &device = THIS->db.config.device;
            device.role = (meshtastic_Config_DeviceConfig_Role)lv_dropdown_get_selected(objects.settings_device_role_dropdown);
            THIS->controller->sendConfig(meshtastic_Config_DeviceConfig{device}, THIS->ownNode);
            THIS->notifyReboot(true);

            lv_obj_add_flag(objects.settings_device_role_panel, LV_OBJ_FLAG_HIDDEN);
            break;
        }
        case eRegion: {
            char buf1[10], buf2[30];
            lv_dropdown_get_selected_str(objects.settings_region_dropdown, buf1, sizeof(buf1));
            lv_snprintf(buf2, sizeof(buf2), _("Region: %s"), buf1);
            lv_label_set_text(objects.basic_settings_region_label, buf2);

            meshtastic_Config_LoRaConfig &lora = THIS->db.config.lora;
            lora.region =
                (meshtastic_Config_LoRaConfig_RegionCode)(lv_dropdown_get_selected(objects.settings_region_dropdown) + 1);
            lora.channel_num = LoRaPresets::getDefaultSlot(lora.region);
            THIS->controller->sendConfig(meshtastic_Config_LoRaConfig{lora}, THIS->ownNode);
            THIS->notifyReboot(true);

            lv_obj_add_flag(objects.settings_region_panel, LV_OBJ_FLAG_HIDDEN);
            break;
        }
        case eModemPreset: {
            char buf1[16], buf2[32];
            lv_dropdown_get_selected_str(objects.settings_modem_preset_dropdown, buf1, sizeof(buf1));
            lv_snprintf(buf2, sizeof(buf2), _("Modem Preset: %s"), buf1);
            lv_label_set_text(objects.basic_settings_modem_preset_label, buf2);

            meshtastic_Config_LoRaConfig &lora = THIS->db.config.lora;
            lora.use_preset = true;
            lora.modem_preset =
                (meshtastic_Config_LoRaConfig_ModemPreset)(lv_dropdown_get_selected(objects.settings_modem_preset_dropdown));
            lora.channel_num = (uint16_t)lv_slider_get_value(objects.frequency_slot_slider);
            THIS->controller->sendConfig(meshtastic_Config_LoRaConfig{lora}, THIS->ownNode);
            THIS->notifyReboot(true);

            lv_obj_add_flag(objects.settings_modem_preset_panel, LV_OBJ_FLAG_HIDDEN);
            break;
        }
        case eChannel: {
            for (int i = 0; i < c_max_channels; i++) {
                // check if channel changed, then update and send to radio
                if (memcmp(&THIS->db.channel[i], &THIS->channel_scratch[i], sizeof(THIS->channel_scratch[i])) != 0) {
                    THIS->channel_scratch[i].has_settings = true;
                    THIS->updateChannelConfig(THIS->channel_scratch[i]);
                    THIS->controller->sendConfig(THIS->channel_scratch[i], THIS->ownNode);
                }
            }

            int8_t ch = (signed long)THIS->ch_label[0]->user_data;
            char buf[32];
            lv_snprintf(buf, sizeof(buf), _("Channel: %s"), THIS->db.channel[ch].settings.name);
            lv_label_set_text(objects.basic_settings_channel_label, buf);

            lv_obj_clear_state(objects.settings_channel_panel, LV_STATE_DISABLED);
            lv_obj_add_flag(objects.settings_channel_panel, LV_OBJ_FLAG_HIDDEN);
            delete[] THIS->channel_scratch;
            break;
        }
        case eLanguage: {
            char buf1[10], buf2[30];
            lv_dropdown_get_selected_str(objects.settings_language_dropdown, buf1, sizeof(buf1));
            lv_snprintf(buf2, sizeof(buf2), _("Language: %s"), buf1);
            lv_label_set_text(objects.basic_settings_language_label, buf2);
            // TODO: change language acc. lvgl localization
            switch (lv_dropdown_get_selected(objects.settings_language_dropdown)) {
            case 0:
                lv_i18n_set_locale("en");
                break;
            case 1:
                lv_i18n_set_locale("de");
                break;
            default:
                ILOG_WARN("Language %s not implemented\n", buf1);
                break;
            }

            lv_obj_add_flag(objects.settings_language_panel, LV_OBJ_FLAG_HIDDEN);
            break;
        }
        case eScreenTimeout: {
            char buf[32];
            uint32_t value = lv_slider_get_value(objects.screen_timeout_slider);
            if (value > 5)
                value -= value % 5;
            THIS->displaydriver->setScreenTimeout(value);
            if (value == 0)
                lv_snprintf(buf, sizeof(buf), "Screen Timeout: off");
            else
                lv_snprintf(buf, sizeof(buf), "Screen Timeout: %ds", value);
            lv_label_set_text(objects.basic_settings_timeout_label, buf);
            lv_obj_add_flag(objects.settings_screen_timeout_panel, LV_OBJ_FLAG_HIDDEN);
            break;
        }
        case eScreenBrightness: {
            char buf[32];
            lv_snprintf(buf, sizeof(buf), "Screen Brightness: %d%%", (int)lv_slider_get_value(objects.brightness_slider));
            lv_label_set_text(objects.basic_settings_brightness_label, buf);
            lv_obj_add_flag(objects.settings_brightness_panel, LV_OBJ_FLAG_HIDDEN);
            break;
        }
        case eInputControl: {
            char new_val_kbd[10], new_val_ptr[10];
            lv_dropdown_get_selected_str(objects.settings_keyboard_input_dropdown, new_val_kbd, sizeof(new_val_kbd));
            lv_dropdown_get_selected_str(objects.settings_mouse_input_dropdown, new_val_ptr, sizeof(new_val_ptr));

            bool error = false;
            if (strcmp(THIS->old_val1_scratch, new_val_kbd) != 0) {
                if (strcmp(THIS->old_val1_scratch, "none") != 0) {
                    THIS->inputdriver->releaseKeyboardDevice();
                }
                if (strcmp(new_val_kbd, "none") != 0) {
                    error &= THIS->inputdriver->useKeyboardDevice(new_val_kbd);
                }
            }
            if (strcmp(THIS->old_val2_scratch, new_val_ptr) != 0) {
                if (strcmp(THIS->old_val2_scratch, "none") != 0) {
                    THIS->inputdriver->releasePointerDevice();
                }
                if (strcmp(new_val_ptr, "none") != 0) {
                    error &= THIS->inputdriver->usePointerDevice(new_val_ptr);
                }
            }

            THIS->setInputButtonLabel();

            if (error) {
                ILOG_WARN("failed to use %s/%s\n", new_val_kbd, new_val_ptr);
                return;
            }

            std::string current_kbd = THIS->inputdriver->getCurrentKeyboardDevice();
            std::string current_ptr = THIS->inputdriver->getCurrentPointerDevice();
            if (strcmp(current_kbd.c_str(), "none") == 0 && strcmp(current_ptr.c_str(), "none") == 0 && THIS->input_group) {
                lv_group_delete(THIS->input_group);
                THIS->input_group = nullptr;
            } else if (strcmp(THIS->old_val1_scratch, current_kbd.c_str()) != 0 ||
                       strcmp(THIS->old_val2_scratch, current_ptr.c_str()) != 0) {
                THIS->setInputGroup();
            }

            lv_obj_add_flag(objects.settings_input_control_panel, LV_OBJ_FLAG_HIDDEN);
            break;
        }
        case eAlertBuzzer: {
            char buf[32];
            meshtastic_ModuleConfig_ExternalNotificationConfig &config = THIS->db.module_config.external_notification;
            int tone = lv_dropdown_get_selected(objects.settings_ringtone_dropdown);

            bool alert_message = lv_obj_has_state(objects.settings_alert_buzzer_switch, LV_STATE_CHECKED);
            if (!config.alert_message_buzzer && alert_message) {
                if (!config.enabled || !config.alert_message_buzzer || !config.use_pwm || !config.use_i2s_as_buzzer) {
                    config.enabled = true;
                    config.alert_message_buzzer = true;
                    config.use_pwm = true;
                    config.use_i2s_as_buzzer = true;
                    config.nag_timeout = 0;
                }
                THIS->notifyReboot(true);
                THIS->controller->sendConfig(meshtastic_ModuleConfig_ExternalNotificationConfig{config}, THIS->ownNode);
            } else if (config.alert_message_buzzer && !alert_message) {
                config.enabled = false;
                THIS->notifyReboot(true);
                THIS->controller->sendConfig(meshtastic_ModuleConfig_ExternalNotificationConfig{config}, THIS->ownNode);
            }

            THIS->controller->sendConfig(ringtone[tone].rtttl, THIS->ownNode);

            lv_snprintf(buf, sizeof(buf), "Message Alert: %s", config.alert_message_buzzer ? ringtone[tone].name : "off");
            lv_label_set_text(objects.basic_settings_alert_label, buf);

            lv_obj_add_flag(objects.settings_alert_buzzer_panel, LV_OBJ_FLAG_HIDDEN);
            break;
        }
        case eReset: {
            uint32_t option = lv_dropdown_get_selected(objects.settings_reset_dropdown);
            THIS->controller->requestReset(option, THIS->ownNode);
            lv_obj_add_flag(objects.settings_reset_panel, LV_OBJ_FLAG_HIDDEN);
            break;
        }
        case eModifyChannel: {
            meshtastic_ChannelSettings_psk_t psk = {};
            const char *name = lv_textarea_get_text(objects.settings_modify_channel_name_textarea);
            const char *base64 = lv_textarea_get_text(objects.settings_modify_channel_psk_textarea);
            uint8_t btn_id = (unsigned long)objects.settings_modify_channel_name_textarea->user_data;
            int8_t ch = (signed long)THIS->ch_label[btn_id]->user_data;

            if (strlen(base64) == 0 && strlen(name) == 0) {
                // delete channel
                THIS->channel_scratch[ch].role = meshtastic_Channel_Role_DISABLED;
                THIS->channel_scratch[ch].settings.psk.size = 0;
                strcpy(THIS->channel_scratch[ch].settings.name, "");
                lv_label_set_text(THIS->ch_label[btn_id], "<unset>");
                THIS->activeSettings = eChannel;
            }

            if (strlen(base64) != 0 && base64[strlen(base64) - 1] != '=')
                lv_textarea_add_text(objects.settings_modify_channel_psk_textarea, "=");

            if (THIS->base64ToPsk(lv_textarea_get_text(objects.settings_modify_channel_psk_textarea), psk)) {
                if (strlen(name) != 0) {
                    // TODO: fill temp storage -> user data
                    lv_label_set_text(THIS->ch_label[btn_id], name);
                    strcpy(THIS->channel_scratch[ch].settings.name, name);
                    memcpy(THIS->channel_scratch[ch].settings.psk.bytes, psk.bytes, 32);
                    THIS->channel_scratch[ch].settings.psk.size = psk.size;
                    THIS->activeSettings = eChannel;
                }
            }

            if (THIS->activeSettings == eChannel) {
                lv_obj_add_flag(objects.settings_modify_channel_panel, LV_OBJ_FLAG_HIDDEN);
                lv_obj_clear_state(objects.settings_channel_panel, LV_STATE_DISABLED);
                lv_obj_remove_flag(objects.settings_channel_panel, LV_OBJ_FLAG_HIDDEN);
            }
            return;
        }
        default:
            ILOG_ERROR("Unhandled ok event\n");
            break;
        }
        THIS->activeSettings = eNone;
    }
}

/**
 * @brief Cancel button user widget handling
 *
 * @param e
 */
void TFTView_320x240::ui_event_cancel(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED) {
        switch (THIS->activeSettings) {
        case TFTView_320x240::eUsername: {
            lv_obj_add_flag(objects.settings_username_panel, LV_OBJ_FLAG_HIDDEN);
            break;
        }
        case TFTView_320x240::eDeviceRole: {
            lv_obj_add_flag(objects.settings_device_role_panel, LV_OBJ_FLAG_HIDDEN);
            break;
        }
        case TFTView_320x240::eRegion: {
            lv_obj_add_flag(objects.settings_region_panel, LV_OBJ_FLAG_HIDDEN);
            break;
        }
        case TFTView_320x240::eModemPreset: {
            lv_obj_add_flag(objects.settings_modem_preset_panel, LV_OBJ_FLAG_HIDDEN);
            break;
        }
        case TFTView_320x240::eChannel: {
            delete[] THIS->channel_scratch;
            lv_obj_add_flag(objects.settings_channel_panel, LV_OBJ_FLAG_HIDDEN);
            break;
        }
        case TFTView_320x240::eLanguage: {
            lv_obj_add_flag(objects.settings_language_panel, LV_OBJ_FLAG_HIDDEN);
            break;
        }
        case TFTView_320x240::eScreenTimeout: {
            lv_obj_add_flag(objects.settings_screen_timeout_panel, LV_OBJ_FLAG_HIDDEN);
            break;
        }
        case TFTView_320x240::eScreenBrightness: {
            lv_obj_add_flag(objects.settings_brightness_panel, LV_OBJ_FLAG_HIDDEN);
            // revert to old brightness value
            uint32_t old_brightness = (unsigned long)objects.brightness_slider->user_data;
            THIS->displaydriver->setBrightness((uint8_t)(old_brightness * 255 / 100));
            break;
        }
        case TFTView_320x240::eInputControl: {
            lv_obj_add_flag(objects.settings_input_control_panel, LV_OBJ_FLAG_HIDDEN);
            break;
        }
        case TFTView_320x240::eAlertBuzzer: {
            lv_obj_add_flag(objects.settings_alert_buzzer_panel, LV_OBJ_FLAG_HIDDEN);
            break;
        }
        case TFTView_320x240::eReset: {
            lv_obj_add_flag(objects.settings_reset_panel, LV_OBJ_FLAG_HIDDEN);
            break;
        }
        case TFTView_320x240::eModifyChannel: {
            lv_obj_add_flag(objects.settings_modify_channel_panel, LV_OBJ_FLAG_HIDDEN);
            lv_obj_clear_state(objects.settings_channel_panel, LV_STATE_DISABLED);
            lv_obj_remove_flag(objects.settings_channel_panel, LV_OBJ_FLAG_HIDDEN);
            THIS->activeSettings = eChannel;
            return;
        }
        default:
            ILOG_ERROR("Unhandled cancel event\n");
            break;
        }

        THIS->activeSettings = eNone;
    }
}

// end button event handlers

void TFTView_320x240::ui_event_screen_timeout_slider(lv_event_t *e)
{
    lv_obj_t *slider = lv_event_get_target_obj(e);
    char buf[20];
    uint32_t value = lv_slider_get_value(slider);
    if (value > 5)
        value -= value % 5;
    if (value == 0)
        lv_snprintf(buf, sizeof(buf), "Timeout: off");
    else
        lv_snprintf(buf, sizeof(buf), "Timeout: %ds", value);
    lv_label_set_text(objects.settings_screen_timeout_label, buf);
}

void TFTView_320x240::ui_event_brightness_slider(lv_event_t *e)
{
    lv_obj_t *slider = lv_event_get_target_obj(e);
    char buf[20];
    lv_snprintf(buf, sizeof(buf), "Brightness: %d%%", (int)lv_slider_get_value(slider));
    lv_label_set_text(objects.settings_brightness_label, buf);
    THIS->displaydriver->setBrightness((uint8_t)(lv_slider_get_value(slider) * 255 / 100));
}

void TFTView_320x240::ui_event_frequency_slot_slider(lv_event_t *e)
{
    lv_obj_t *slider = lv_event_get_target_obj(e);
    char buf[40];
    uint32_t channel = (uint32_t)lv_slider_get_value(slider);
    sprintf(buf, "FrequencySlot: %d (%.2f MHz)", channel,
            LoRaPresets::getRadioFreq(
                THIS->db.config.lora.region,
                (meshtastic_Config_LoRaConfig_ModemPreset)lv_dropdown_get_selected(objects.settings_modem_preset_dropdown),
                channel));
    lv_label_set_text(objects.frequency_slot_label, buf);
}

void TFTView_320x240::ui_event_modem_preset_dropdown(lv_event_t *e)
{
    lv_obj_t *dropdown = lv_event_get_target_obj(e);
    meshtastic_Config_LoRaConfig_ModemPreset preset =
        (meshtastic_Config_LoRaConfig_ModemPreset)lv_dropdown_get_selected(dropdown);
    uint32_t numChannels = LoRaPresets::getNumChannels(THIS->db.config.lora.region, preset);

    uint32_t channel = LoRaPresets::getDefaultSlot(THIS->db.config.lora.region);
    lv_slider_set_range(objects.frequency_slot_slider, 1, numChannels);
    lv_slider_set_value(objects.frequency_slot_slider, channel, LV_ANIM_OFF);

    char buf[40];
    sprintf(buf, "FrequencySlot: %d (%.2f MHz)", channel,
            LoRaPresets::getRadioFreq(THIS->db.config.lora.region, preset, channel));
    lv_label_set_text(objects.frequency_slot_label, buf);
}

// animations
void TFTView_320x240::ui_anim_node_panel_cb(void *var, int32_t v)
{
    lv_obj_set_height((lv_obj_t *)var, v);
}

/**
 * @brief Dynamically show user widget
 *        First a panel is created where the widget is located in, then the widget is drawn.
 *        "active_widget" contains the surrounding panel which must be destroyed
 *        to remove the widget from the screen (e.g. by pressing OK/Cancel).
 *
 * @param func
 */
void TFTView_320x240::showUserWidget(UserWidgetFunc createWidget)
{
    lv_obj_t *obj = lv_obj_create(objects.main_screen);
    lv_obj_set_pos(obj, 39, 25);
    lv_obj_set_size(obj, LV_PCT(88), LV_PCT(90));
    lv_obj_add_flag(obj, LV_OBJ_FLAG_HIDDEN);
    lv_obj_clear_flag(obj, LV_OBJ_FLAG_SCROLLABLE);
    lv_obj_set_style_bg_color(obj, lv_color_hex(0xff303030), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_width(obj, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_radius(obj, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    activeWidget = obj;

    createWidget(activeWidget, NULL, 0);
}

void TFTView_320x240::handleAddMessage(char *msg)
{
    // retrieve nodeNum + channel from activeMsgContainer
    uint8_t ch;
    uint32_t requestId;
    uint32_t to = UINT32_MAX;
    uint32_t channelOrNode = (unsigned long)activeMsgContainer->user_data;
    if (channelOrNode < c_max_channels) {
        ch = (uint8_t)channelOrNode;
        requestId = requests.addRequest(ch);
    } else {
        ch = (uint8_t)(unsigned long)nodes[channelOrNode]->user_data;
        to = channelOrNode;
        requestId = requests.addRequest(to);
    }

    controller->sendTextMessage(to, ch, requestId, msg);
    addMessage(requestId, msg);
}

/**
 * display message that has just been written and sent out
 */
void TFTView_320x240::addMessage(uint32_t requestId, char *msg)
{
    lv_obj_t *hiddenPanel = lv_obj_create(activeMsgContainer);
    lv_obj_set_width(hiddenPanel, lv_pct(100));
    lv_obj_set_height(hiddenPanel, LV_SIZE_CONTENT);
    lv_obj_set_align(hiddenPanel, LV_ALIGN_CENTER);
    lv_obj_clear_flag(hiddenPanel, LV_OBJ_FLAG_SCROLLABLE);
    lv_obj_set_style_radius(hiddenPanel, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(hiddenPanel, lv_color_hex(0x303030), LV_PART_MAIN | LV_STATE_DEFAULT);
    // lv_obj_set_style_bg_opa(hiddenPanel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_width(hiddenPanel, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_left(hiddenPanel, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_right(hiddenPanel, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_top(hiddenPanel, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_bottom(hiddenPanel, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    hiddenPanel->user_data = (void *)requestId;

    lv_obj_t *textLabel = lv_label_create(hiddenPanel);
    // calculate expected size of text bubble, to make it look nicer
    lv_coord_t width = lv_txt_get_width(msg, strlen(msg), &ui_font_montserrat_12, 0);
    lv_obj_set_width(textLabel, std::max(std::min(width + 20, 200), 40));
    lv_obj_set_height(textLabel, LV_SIZE_CONTENT);
    lv_obj_set_y(textLabel, 0);
    lv_obj_set_align(textLabel, LV_ALIGN_RIGHT_MID);

    // tweak to allow multiple lines in single line text area
    for (int i = 0; i < strlen(msg); i++)
        if (msg[i] == CR_REPLACEMENT)
            msg[i] = '\n';
    lv_label_set_text(textLabel, msg);
    lv_obj_set_style_text_color(textLabel, lv_color_hex(0xF0F0F0), LV_PART_MAIN | LV_STATE_DEFAULT);
    // lv_obj_set_style_text_opa(textLabel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_align(textLabel, LV_TEXT_ALIGN_LEFT, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(textLabel, &ui_font_montserrat_12, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_radius(textLabel, 10, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(textLabel, lv_color_hex(0x404040), LV_PART_MAIN | LV_STATE_DEFAULT);
    // lv_obj_set_style_bg_opa(textLabel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_color(textLabel, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_opa(textLabel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_width(textLabel, 2, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_left(textLabel, 8, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_right(textLabel, 5, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_top(textLabel, 1, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_bottom(textLabel, 1, LV_PART_MAIN | LV_STATE_DEFAULT);

    lv_obj_scroll_to_view(hiddenPanel, LV_ANIM_ON);
}

void TFTView_320x240::addNode(uint32_t nodeNum, uint8_t ch, const char *userShort, const char *userLong, uint32_t lastHeard,
                              eRole role, bool viaMqtt)
{
    // lv_obj nodesPanel children
    // [0]: img
    // [1]: btn
    // [2]: lbl user long
    // [3]: lbl user short
    // [4]: lbl battery
    // [5]: lbl lastHeard
    // [6]: lbl signal
    // [7]: lbl position 1
    // [8]: lbl position 2
    // [9]: lbl telemetry 1
    // [10]: lbl telemetry 2
    // user_data: ch

    lv_obj_t *p = lv_obj_create(objects.nodes_panel);
    p->user_data = (void *)(uint32_t)ch;
    nodes[nodeNum] = p;
    nodeCount++;
    // NodePanel
    lv_obj_set_height(p, 52);
    lv_obj_set_width(p, lv_pct(100));
    lv_obj_set_align(p, LV_ALIGN_CENTER);
    lv_obj_clear_flag(p, LV_OBJ_FLAG_CLICKABLE | LV_OBJ_FLAG_PRESS_LOCK | LV_OBJ_FLAG_CLICK_FOCUSABLE |
                             LV_OBJ_FLAG_GESTURE_BUBBLE | LV_OBJ_FLAG_SNAPPABLE | LV_OBJ_FLAG_SCROLLABLE |
                             LV_OBJ_FLAG_SCROLL_ELASTIC | LV_OBJ_FLAG_SCROLL_MOMENTUM); /// Flags
    lv_obj_set_scrollbar_mode(p, LV_SCROLLBAR_MODE_OFF);
    lv_obj_set_style_bg_color(p, lv_color_hex(0x404040), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(p, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_color(p, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_opa(p, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_width(p, 1, LV_PART_MAIN | LV_STATE_DEFAULT);
    // NodeImage
    lv_obj_t *img = lv_img_create(p);
    setNodeImage(nodeNum, role, viaMqtt, img);
    lv_obj_set_width(img, LV_SIZE_CONTENT);
    lv_obj_set_height(img, LV_SIZE_CONTENT);
    lv_obj_set_x(img, -5);
    lv_obj_set_y(img, -10);
    lv_obj_add_flag(img, LV_OBJ_FLAG_ADV_HITTEST);
    lv_obj_clear_flag(img, LV_OBJ_FLAG_SCROLLABLE);
    lv_obj_set_style_radius(img, 6, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(img, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_opa(img, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_width(img, 3, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_img_recolor(img, lv_color_hex(0x202020), LV_PART_MAIN | LV_STATE_DEFAULT);
    img->user_data = (void *)viaMqtt; // used for filtering (applyNodesFilter)
    // NodeButton
    lv_obj_t *nodeButton = lv_btn_create(p);
    lv_obj_set_size(nodeButton, LV_PCT(70), LV_PCT(100));
    lv_obj_set_x(nodeButton, -13);
    lv_obj_set_y(nodeButton, 0);
    lv_obj_set_align(nodeButton, LV_ALIGN_TOP_LEFT);
    lv_obj_add_flag(nodeButton, LV_OBJ_FLAG_SCROLL_ON_FOCUS);
    lv_obj_set_style_bg_color(nodeButton, lv_color_hex(0xFFFFFF), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(nodeButton, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_color(nodeButton, lv_color_hex(0x000000), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_opa(nodeButton, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_width(nodeButton, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_shadow_width(nodeButton, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_shadow_spread(nodeButton, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_max_height(nodeButton, 100, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_min_height(nodeButton, 50, LV_PART_MAIN | LV_STATE_DEFAULT);
    // UserNameLabel
    lv_obj_t *ln_lbl = lv_label_create(p);
    lv_obj_set_pos(ln_lbl, -5, 21);
    lv_obj_set_size(ln_lbl, LV_PCT(80), LV_SIZE_CONTENT);
    lv_label_set_long_mode(ln_lbl, LV_LABEL_LONG_SCROLL);
    lv_label_set_text(ln_lbl, userLong);
    ln_lbl->user_data = (void *)strlen(userLong);
    lv_obj_set_style_align(ln_lbl, LV_ALIGN_TOP_LEFT, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_color(ln_lbl, lv_color_hex(0xF0F0F0), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ln_lbl, &ui_font_montserrat_12, LV_PART_MAIN | LV_STATE_DEFAULT);
    // UserNameShortLabel
    lv_obj_t *sn_lbl = lv_label_create(p);
    lv_obj_set_width(sn_lbl, LV_SIZE_CONTENT);
    lv_obj_set_height(sn_lbl, LV_SIZE_CONTENT);
    lv_obj_set_x(sn_lbl, 30);
    lv_obj_set_y(sn_lbl, -5);
    lv_obj_set_align(sn_lbl, LV_ALIGN_LEFT_MID);
    lv_label_set_text(sn_lbl, userShort);
    lv_obj_set_style_align(sn_lbl, LV_ALIGN_TOP_LEFT, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_color(sn_lbl, lv_color_hex(0xFFFFFF), LV_PART_MAIN | LV_STATE_DEFAULT);
    // lv_obj_set_style_text_opa(sn_lbl, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    //  BatteryLabel
    lv_obj_t *ui_BatteryLabel = lv_label_create(p);
    lv_obj_set_pos(ui_BatteryLabel, 8, 4);
    lv_obj_set_size(ui_BatteryLabel, LV_SIZE_CONTENT, LV_SIZE_CONTENT);
    lv_obj_set_align(ui_BatteryLabel, LV_ALIGN_TOP_RIGHT);
    lv_label_set_text(ui_BatteryLabel, "");
    lv_obj_set_style_text_color(ui_BatteryLabel, lv_color_hex(0xF0F0F0), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_opa(ui_BatteryLabel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_align(ui_BatteryLabel, LV_TEXT_ALIGN_RIGHT, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_BatteryLabel, &ui_font_montserrat_12, LV_PART_MAIN | LV_STATE_DEFAULT);
    // LastHeardLabel
    lv_obj_t *ui_lastHeardLabel = lv_label_create(p);
    lv_obj_set_pos(ui_lastHeardLabel, 8, 20);
    lv_obj_set_size(ui_lastHeardLabel, LV_SIZE_CONTENT, LV_SIZE_CONTENT);
    lv_obj_set_style_align(ui_lastHeardLabel, LV_ALIGN_TOP_RIGHT, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_label_set_long_mode(ui_lastHeardLabel, LV_LABEL_LONG_CLIP);

    // TODO: devices without actual time will report all nodes as lastseen = now
    if (lastHeard) {
        time_t curtime;
        time(&curtime);
        lastHeard = std::min(curtime, (time_t)lastHeard); // adapt values too large

        char buf[12];
        bool isOnline = lastHeartToString(lastHeard, buf);
        lv_label_set_text(ui_lastHeardLabel, buf);
        if (isOnline) {
            nodesOnline++;
        }
    } else {
        lv_label_set_text(ui_lastHeardLabel, "");
    }

    lv_obj_set_style_text_color(ui_lastHeardLabel, lv_color_hex(0xF0F0F0), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_opa(ui_lastHeardLabel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_align(ui_lastHeardLabel, LV_TEXT_ALIGN_RIGHT, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_lastHeardLabel, &ui_font_montserrat_12, LV_PART_MAIN | LV_STATE_DEFAULT);
    ui_lastHeardLabel->user_data = (void *)lastHeard;
    // SignalLabel
    lv_obj_t *ui_SignalLabel = lv_label_create(p);
    lv_obj_set_width(ui_SignalLabel, LV_SIZE_CONTENT);
    lv_obj_set_height(ui_SignalLabel, LV_SIZE_CONTENT);
    lv_obj_set_pos(ui_SignalLabel, 8, -12);
    lv_obj_set_align(ui_SignalLabel, LV_ALIGN_TOP_RIGHT);
    lv_label_set_text(ui_SignalLabel, "");
    lv_obj_set_style_text_color(ui_SignalLabel, lv_color_hex(0xFFFFFF), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_opa(ui_SignalLabel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_SignalLabel, &ui_font_montserrat_12, LV_PART_MAIN | LV_STATE_DEFAULT);

    // PositionLabel
    lv_obj_t *ui_PositionLabel = lv_label_create(p);
    lv_obj_set_pos(ui_PositionLabel, -5, 36);
    lv_obj_set_size(ui_PositionLabel, 120, LV_SIZE_CONTENT);
    lv_label_set_long_mode(ui_PositionLabel, LV_LABEL_LONG_CLIP);
    lv_label_set_text(ui_PositionLabel, "");
    lv_obj_set_style_align(ui_PositionLabel, LV_ALIGN_TOP_LEFT, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_color(ui_PositionLabel, lv_color_hex(0xff05f6cb), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_PositionLabel, &ui_font_montserrat_12, LV_PART_MAIN | LV_STATE_DEFAULT);
    // Position2Label
    lv_obj_t *ui_Position2Label = lv_label_create(p);
    lv_obj_set_pos(ui_Position2Label, -5, 50);
    lv_obj_set_size(ui_Position2Label, 108, LV_SIZE_CONTENT);
    lv_label_set_long_mode(ui_Position2Label, LV_LABEL_LONG_SCROLL);
    lv_label_set_text(ui_Position2Label, "");
    lv_obj_set_style_align(ui_Position2Label, LV_ALIGN_TOP_LEFT, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_color(ui_Position2Label, lv_color_hex(0xfff0f0f0), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_Position2Label, &ui_font_montserrat_12, LV_PART_MAIN | LV_STATE_DEFAULT);
    // Telemetry1Label
    lv_obj_t *ui_Telemetry1Label = lv_label_create(p);
    lv_obj_set_pos(ui_Telemetry1Label, 8, 36);
    lv_obj_set_size(ui_Telemetry1Label, 130, LV_SIZE_CONTENT);
    lv_label_set_long_mode(ui_Telemetry1Label, LV_LABEL_LONG_CLIP);
    lv_label_set_text(ui_Telemetry1Label, "");
    lv_obj_set_style_align(ui_Telemetry1Label, LV_ALIGN_TOP_RIGHT, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_color(ui_Telemetry1Label, lv_color_hex(0xfff0f0f0), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_Telemetry1Label, &ui_font_montserrat_12, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_align(ui_Telemetry1Label, LV_TEXT_ALIGN_RIGHT, LV_PART_MAIN | LV_STATE_DEFAULT);
    // Telemetry2Label
    lv_obj_t *ui_Telemetry2Label = lv_label_create(p);
    lv_obj_set_pos(ui_Telemetry2Label, 8, 50);
    lv_obj_set_size(ui_Telemetry2Label, 130, LV_SIZE_CONTENT);
    lv_label_set_long_mode(ui_Telemetry2Label, LV_LABEL_LONG_CLIP);
    lv_label_set_text(ui_Telemetry2Label, "");
    lv_obj_set_style_align(ui_Telemetry2Label, LV_ALIGN_TOP_RIGHT, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_color(ui_Telemetry2Label, lv_color_hex(0xfff0f0f0), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_Telemetry2Label, &ui_font_montserrat_12, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_align(ui_Telemetry2Label, LV_TEXT_ALIGN_RIGHT, LV_PART_MAIN | LV_STATE_DEFAULT);

    lv_obj_add_event_cb(nodeButton, ui_event_NodeButton, LV_EVENT_ALL, (void *)nodeNum);

    applyNodesFilter(nodeNum);

    // move node into new position within nodePanel
    if (lastHeard) {
        lv_obj_t **children = objects.nodes_panel->spec_attr->children;
        int i = objects.nodes_panel->spec_attr->child_cnt - 1;
        while (i > 1) {
            if (lastHeard <= (time_t)(children[i - 1]->LV_OBJ_IDX(node_lh_idx)->user_data))
                break;
            i--;
        }
        if (i >= 1 && i < objects.nodes_panel->spec_attr->child_cnt - 1) {
            lv_obj_move_to_index(p, i);
        }
    }

    updateNodesStatus();
}

void TFTView_320x240::setMyInfo(uint32_t nodeNum)
{
    ownNode = nodeNum;
    nodes[ownNode] = objects.node_panel;
}

void TFTView_320x240::setDeviceMetaData(int hw_model, const char *version, bool has_bluetooth, bool has_wifi, bool has_eth,
                                        bool can_shutdown)
{
}

void TFTView_320x240::addOrUpdateNode(uint32_t nodeNum, uint8_t ch, const char *userShort, const char *userLong,
                                      uint32_t lastHeard, eRole role, bool viaMqtt)
{
    if (nodes.find(nodeNum) == nodes.end()) {
        addNode(nodeNum, ch, userShort, userLong, lastHeard, role, viaMqtt);
    } else {
        updateNode(nodeNum, ch, userShort, userLong, lastHeard, role, viaMqtt);
    }
}

/**
 * @brief update node userName and image
 *
 * @param nodeNum
 * @param ch
 * @param userShort
 * @param userLong
 * @param lastHeard
 * @param role
 * @param viaMqtt
 */
void TFTView_320x240::updateNode(uint32_t nodeNum, uint8_t ch, const char *userShort, const char *userLong, uint32_t lastHeard,
                                 eRole role, bool viaMqtt)
{
    auto it = nodes.find(nodeNum);
    if (it != nodes.end()) {
        if (it->first == ownNode) {
            // update related settings buttons and store role in image user data
            char buf[30];
            lv_snprintf(buf, sizeof(buf), _("User name: %s"), userShort);
            lv_label_set_text(objects.basic_settings_user_label, buf);
            lv_snprintf(buf, sizeof(buf), _("Device Role: %s"), deviceRoleToString(role));
            lv_label_set_text(objects.basic_settings_role_label, buf);
            it->second->LV_OBJ_IDX(node_img_idx)->user_data = (void *)role; // TODO: not used -> remove?

            // update DB
            strcpy(db.short_name, userShort);
            strcpy(db.long_name, userLong);
            db.config.device.role = (meshtastic_Config_DeviceConfig_Role)role;
        }
        lv_label_set_text(it->second->LV_OBJ_IDX(node_lbl_idx), userLong);
        it->second->LV_OBJ_IDX(node_lbl_idx)->user_data = (void *)strlen(userLong);
        lv_label_set_text(it->second->LV_OBJ_IDX(node_lbs_idx), userShort);
        setNodeImage(nodeNum, role, viaMqtt, it->second->LV_OBJ_IDX(node_img_idx));
    }
}

void TFTView_320x240::updatePosition(uint32_t nodeNum, int32_t lat, int32_t lon, int32_t alt, uint32_t sats, uint32_t precision)
{
    if (nodeNum == ownNode) {
        char buf[64];
        int latSeconds = (int)round(lat * 1e-7 * 3600);
        int latDegrees = latSeconds / 3600;
        latSeconds = abs(latSeconds % 3600);
        int latMinutes = latSeconds / 60;
        latSeconds %= 60;
        char latLetter = (lat > 0) ? 'N' : 'S';

        int lonSeconds = (int)round(lon * 1e-7 * 3600);
        int lonDegrees = lonSeconds / 3600;
        lonSeconds = abs(lonSeconds % 3600);
        int lonMinutes = lonSeconds / 60;
        lonSeconds %= 60;
        char lonLetter = (lon > 0) ? 'E' : 'W';

        if (sats)
            sprintf(buf, "%c%02i %2i'%02i\"   %u sats\n%c%02i %2i'%02i\"   %dm", latLetter, abs(latDegrees), latMinutes,
                    latSeconds, sats, lonLetter, abs(lonDegrees), lonMinutes, lonSeconds, abs(alt) < 10000 ? alt : 0);
        else
            sprintf(buf, "%c%02i %2i'%02i\"\n%c%02i %2i'%02i\"   %dm", latLetter, abs(latDegrees), latMinutes, latSeconds,
                    lonLetter, abs(lonDegrees), lonMinutes, lonSeconds, abs(alt) < 10000 ? alt : 0);

        //        sprintf(buf, "%f\n%f", lat * 1e-7, lon * 1e-7);
        lv_label_set_text(objects.home_location_label, buf);
    }

    if (lat != 0 && lon != 0) {
        char buf[32];
        sprintf(buf, "%.5f %.5f", lat * 1e-7, lon * 1e-7);
        // sprintf(buf, "%d %d", lat, lon);
        lv_obj_t *panel = nodes[nodeNum];
        lv_label_set_text(panel->LV_OBJ_IDX(node_pos1_idx), buf);
        if (sats)
            sprintf(buf, "%dm MSL  %u sats", abs(alt) < 10000 ? alt : 0, sats);
        sprintf(buf, "%dm MSL", abs(alt) < 10000 ? alt : 0);
        lv_label_set_text(panel->LV_OBJ_IDX(node_pos2_idx), buf);
    }

    applyNodesFilter(nodeNum);
}

/**
 * @brief Update battery level and air utilisation
 *
 * @param nodeNum
 * @param bat_level
 * @param voltage
 * @param chUtil
 * @param airUtil
 */
void TFTView_320x240::updateMetrics(uint32_t nodeNum, uint32_t bat_level, float voltage, float chUtil, float airUtil)
{
    auto it = nodes.find(nodeNum);
    if (it != nodes.end()) {
        char buf[32];
        if (it->first == ownNode) {
            sprintf(buf, "Util %0.1f%% %0.1f%%", chUtil, airUtil);
            lv_label_set_text(it->second->LV_OBJ_IDX(node_sig_idx), buf);

            // update battery percentage and symbol
            if (bat_level != 0 || voltage != 0) {
                uint32_t shown_level = std::min(bat_level, (uint32_t)100);
                sprintf(buf, "%d%%", shown_level);
                lv_label_set_text(objects.battery_percentage_label, buf);
                lv_opa_t recolor = 0;
                uint32_t txtColor = 0xE0E0E0;
                if (bat_level > 100 && voltage > 4.3)
                    lv_img_set_src(objects.battery_image, &img_battery_bolt_image);
                else if (bat_level > 80)
                    lv_img_set_src(objects.battery_image, &img_battery_full_image);
                else if (bat_level > 30)
                    lv_img_set_src(objects.battery_image, &img_battery_mid_image);
                else if (bat_level > 5)
                    lv_img_set_src(objects.battery_image, &img_battery_low_image);
                else if (bat_level > 1) {
                    lv_img_set_src(objects.battery_image, &img_battery_empty_image);
                    recolor = 255;
                    txtColor = 0xF72b2b;
                } else {
                    lv_img_set_src(objects.battery_image, &img_battery_slash_image);
                    recolor = 255;
                    txtColor = 0xF72b2b;
                }
                lv_obj_set_style_img_recolor_opa(objects.battery_image, recolor, LV_PART_MAIN | LV_STATE_DEFAULT);
                lv_obj_set_style_text_color(objects.battery_percentage_label, lv_color_hex(txtColor),
                                            LV_PART_MAIN | LV_STATE_DEFAULT);
            }
        }

        if (bat_level != 0 || voltage != 0) {
            bat_level = std::min(bat_level, (uint32_t)100);
            sprintf(buf, "%d%% %0.2fV", bat_level, voltage);
            lv_label_set_text(it->second->LV_OBJ_IDX(node_bat_idx), buf);
        }
    }
}

void TFTView_320x240::updateEnvironmentMetrics(uint32_t nodeNum, const meshtastic_EnvironmentMetrics &metrics)
{
    auto it = nodes.find(nodeNum);
    if (it != nodes.end()) {
        char buf[50];
        if ((int)metrics.relative_humidity > 0) {
            sprintf(buf, "%2.1fC %d%% %3.1fhPa", metrics.temperature, (int)metrics.relative_humidity,
                    metrics.barometric_pressure);
        } else {
            sprintf(buf, "%2.1fC %3.1fhPa", metrics.temperature, metrics.barometric_pressure);
        }
        lv_label_set_text(it->second->LV_OBJ_IDX(node_tm1_idx), buf);

        if (metrics.iaq > 0 && metrics.iaq < 1000) {
            sprintf(buf, "IAQ: %d %.1fV %.1fmA", metrics.iaq, metrics.voltage, metrics.current);
            lv_label_set_text(it->second->LV_OBJ_IDX(node_tm2_idx), buf);
            it->second->LV_OBJ_IDX(node_tm2_idx)->user_data = (void *)(uint32_t)metrics.iaq;
        }
        applyNodesFilter(nodeNum);
    }
}

void TFTView_320x240::updateAirQualityMetrics(uint32_t nodeNum, const meshtastic_AirQualityMetrics &metrics)
{
    auto it = nodes.find(nodeNum);
    if (it != nodes.end() && it->first != ownNode) {
        // TODO
        // char buf[32];
        // sprintf(buf, "%d %d", metrics.particles_03um, metrics.pm100_environmental);
        // lv_label_set_text(it->second->LV_OBJ_IDX(node_tm2_idx), buf);
    }
}

void TFTView_320x240::updatePowerMetrics(uint32_t nodeNum, const meshtastic_PowerMetrics &metrics)
{
    auto it = nodes.find(nodeNum);
    if (it != nodes.end() && it->first != ownNode) {
        // TODO
        // char buf[32];
        // sprintf(buf, "%0.1fmA %0.2fV", metrics.ch1_current, metrics.ch1_voltage);
        // lv_label_set_text(it->second->LV_OBJ_IDX(node_tm2_idx), buf);
    }
}

void TFTView_320x240::updateSignalStrength(uint32_t nodeNum, int32_t rssi, float snr)
{
    if (nodeNum != ownNode) {
        auto it = nodes.find(nodeNum);
        if (it != nodes.end()) {
            char buf[30];
            if (rssi == 0.0 && snr == 0.0) {
                buf[0] = '\0';
            } else {
                sprintf(buf, "rssi: %d snr: %.1f", rssi, snr);
            }
            lv_label_set_text(it->second->LV_OBJ_IDX(node_sig_idx), buf);
        }
    }
}

void TFTView_320x240::updateHopsAway(uint32_t nodeNum, uint8_t hopsAway)
{
    if (nodeNum != ownNode) {
        auto it = nodes.find(nodeNum);
        if (it != nodes.end()) {
            char buf[16];
            sprintf(buf, "hops: %d", (int)hopsAway);
            lv_label_set_text(it->second->LV_OBJ_IDX(node_sig_idx), buf);
        }
    }
}

void TFTView_320x240::updateConnectionStatus(const meshtastic_DeviceConnectionStatus &status)
{
    if (status.has_wifi) {
        if (status.wifi.has_status) {
            char buf[16];
            uint32_t ip = status.wifi.status.ip_address;
            sprintf(buf, "%d.%d.%d.%d", ip & 0xff000000, ip & 0xff0000, ip & 0xff00, ip & 0xff);
            lv_label_set_text(objects.home_wlan_label, buf);
            if (status.wifi.status.is_connected) {
                lv_obj_set_style_bg_img_recolor_opa(objects.home_wlan_button, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
                lv_obj_set_style_bg_img_src(objects.home_wlan_button, &img_home_wlan_button_image,
                                            LV_PART_MAIN | LV_STATE_DEFAULT);
            } else {
                lv_obj_set_style_bg_img_recolor_opa(objects.home_wlan_button, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
                lv_obj_set_style_bg_img_src(objects.home_wlan_button, &img_home_wlan_button_image,
                                            LV_PART_MAIN | LV_STATE_DEFAULT);
            }
        }
    } else {
        lv_obj_set_style_bg_img_recolor_opa(objects.home_wlan_button, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_obj_set_style_bg_img_src(objects.home_wlan_button, &img_home_wlan_off_image, LV_PART_MAIN | LV_STATE_DEFAULT);
    }
    if (status.has_bluetooth) {
        if (status.bluetooth.is_connected) {
            char buf[16];
            uint32_t mac = ownNode;
            sprintf(buf, "??:??:%02x:%02x:%02x:%02x", mac & 0xff000000, mac & 0xff0000, mac & 0xff00, mac & 0xff);
            lv_label_set_text(objects.home_bluetooth_label, buf);
            lv_obj_set_style_bg_opa(objects.home_bluetooth_button, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
            lv_obj_set_style_bg_img_src(objects.home_bluetooth_button, &img_home_bluetooth_on_button_image,
                                        LV_PART_MAIN | LV_STATE_DEFAULT);
        } else {
            lv_obj_set_style_bg_img_src(objects.home_bluetooth_button, &img_home_bluetooth_on_button_image,
                                        LV_PART_MAIN | LV_STATE_DEFAULT);
            lv_obj_set_style_bg_img_recolor_opa(objects.home_bluetooth_button, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
        }
    } else {
        lv_obj_set_style_bg_img_src(objects.home_bluetooth_button, &img_home_bluetooth_off_button_image,
                                    LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_obj_set_style_bg_img_recolor_opa(objects.home_bluetooth_button, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    }
}

void TFTView_320x240::handleResponse(uint32_t from, const uint32_t id, const meshtastic_Routing &routing)
{
    uint32_t nodeNum;
    bool ack = false;
    if (from == ownNode) {
        nodeNum = requests.findRequest(id);
    } else {
        nodeNum = requests.removeRequest(id);
        ack = true;
    }

    if (nodeNum == UINT32_MAX) {
        ILOG_WARN("request id 0x%08x not valid (anymore)\n", id);
    }
    switch (routing.which_variant) {
    case meshtastic_Routing_error_reason_tag: {
        if (routing.error_reason == meshtastic_Routing_Error_NONE) {
            responseReceived(nodeNum, id, ack);
        } else if (routing.error_reason == meshtastic_Routing_Error_MAX_RETRANSMIT) {
            requests.removeRequest(id);
        } else {
            ILOG_DEBUG("got Routing_Error %d\n", routing.error_reason);
        }
        break;
    }
    case meshtastic_Routing_route_request_tag: {
        ILOG_DEBUG("got meshtastic_Routing_route_request_tag\n");

        break;
    }
    case meshtastic_Routing_route_reply_tag: {
        ILOG_DEBUG("got meshtastic_Routing_route_reply_tag\n");

        break;
    }
    default:
        ILOG_ERROR("unhandled meshtastic_Routing tag\n");
        break;
    }
}

/**
 * @brief apply enabled filters and highlight node
 *
 * @param nodeNum
 * @param reset : set true when filter has changed (to recalculate number of filtered nodes)
 * @return true
 * @return false
 */
bool TFTView_320x240::applyNodesFilter(uint32_t nodeNum, bool reset)
{
    lv_obj_t *panel = nodes[nodeNum];
    bool hide = false;
    if (nodeNum != ownNode /* && filter.active*/) { // TODO
        if (lv_obj_has_state(ui_NodesFilterUnknownSwitch, LV_STATE_CHECKED)) {
            if (lv_img_get_src(panel->LV_OBJ_IDX(node_img_idx)) == &img_circle_question_image) {
                hide = true;
            }
        }
        if (lv_obj_has_state(ui_NodesFilterOfflineSwitch, LV_STATE_CHECKED)) {
            time_t curtime, lastHeard = (time_t)panel->LV_OBJ_IDX(node_lh_idx)->user_data;
            time(&curtime);
            if (curtime - lastHeard - 10 > 15 * 60)
                hide = true;
        }
        if (lv_obj_has_state(ui_NodesFilterMQTTSwitch, LV_STATE_CHECKED)) {
            bool viaMqtt = (unsigned long)panel->LV_OBJ_IDX(node_img_idx)->user_data;
            if (viaMqtt)
                hide = true;
        }
        if (lv_obj_has_state(ui_NodesFilterPositionSwitch, LV_STATE_CHECKED)) {
            if (lv_label_get_text(panel->LV_OBJ_IDX(node_pos1_idx))[0] == '\0')
                hide = true;
        }
        const char *name = lv_textarea_get_text(ui_NodesFilterNameArea);
        if (name[0] != '\0') {
            if (name[0] != '!') { // use '!' char to negate search result
                if (!strcasestr(lv_label_get_text(panel->LV_OBJ_IDX(node_lbl_idx)), name) &&
                    !strcasestr(lv_label_get_text(panel->LV_OBJ_IDX(node_lbs_idx)), name)) {
                    hide = true;
                }
            } else {
                if (strcasestr(lv_label_get_text(panel->LV_OBJ_IDX(node_lbl_idx)), &name[1]) ||
                    strcasestr(lv_label_get_text(panel->LV_OBJ_IDX(node_lbs_idx)), &name[1])) {
                    hide = true;
                }
            }
        }
    }
    if (hide) {
        if (reset || !lv_obj_has_flag(panel, LV_OBJ_FLAG_HIDDEN)) {
            lv_obj_add_flag(panel, LV_OBJ_FLAG_HIDDEN);
            nodesFiltered++;
        }
    } else {
        lv_obj_clear_flag(panel, LV_OBJ_FLAG_HIDDEN);
    }

    bool highlight = false;
    if (true /*highlight.active*/) { // TODO
        if (lv_obj_has_state(ui_NodesHLActiveChatSwitch, LV_STATE_CHECKED)) {
            auto it = chats.find(nodeNum);
            if (it != nodes.end()) {
                lv_obj_set_style_border_color(panel, lv_color_hex(0xffff8c04), LV_PART_MAIN | LV_STATE_DEFAULT);
                highlight = true;
            }
        }
        if (lv_obj_has_state(ui_NodesHLPositionSwitch, LV_STATE_CHECKED)) {
            if (lv_label_get_text(panel->LV_OBJ_IDX(node_pos1_idx))[0] != '\0') {
                lv_obj_set_style_border_color(panel, lv_color_hex(0xff05f6cb), LV_PART_MAIN | LV_STATE_DEFAULT);
                highlight = true;
            }
        }
        if (lv_obj_has_state(ui_NodesHLTelemetrySwitch, LV_STATE_CHECKED)) {
            if (lv_label_get_text(panel->LV_OBJ_IDX(node_tm1_idx))[0] != '\0') {
                lv_obj_set_style_border_color(panel, lv_color_hex(0xff436C70), LV_PART_MAIN | LV_STATE_DEFAULT);
                lv_obj_set_style_border_width(panel, 2, LV_PART_MAIN | LV_STATE_DEFAULT);
                highlight = true;
            }
        }
        if (lv_obj_has_state(ui_NodesHLIAQSwitch, LV_STATE_CHECKED)) {
            if (lv_label_get_text(panel->LV_OBJ_IDX(node_tm2_idx))[0] != '\0') {
                uint32_t iaq = (unsigned long)panel->LV_OBJ_IDX(node_tm2_idx)->user_data;
                // IAQ color code
                lv_color_t fg, bg;
                if (iaq <= 50) {
                    fg = lv_color_hex(0x00000000);
                    bg = lv_color_hex(0x000ce810);
                } else if (iaq <= 100) {
                    fg = lv_color_hex(0x00000000);
                    bg = lv_color_hex(0x00faf646);
                } else if (iaq <= 150) {
                    fg = lv_color_hex(0x00000000);
                    bg = lv_color_hex(0x00f98204);
                } else if (iaq <= 200) {
                    fg = lv_color_hex(0x00000000);
                    bg = lv_color_hex(0x00e42104);
                } else if (iaq <= 300) {
                    fg = lv_color_hex(0xffffffff);
                    bg = lv_color_hex(0x009b2970);
                } else {
                    fg = lv_color_hex(0xffffffff);
                    bg = lv_color_hex(0x001d1414);
                }
                lv_obj_set_style_text_color(panel->LV_OBJ_IDX(node_tm2_idx), fg, LV_PART_MAIN | LV_STATE_DEFAULT);
                lv_obj_set_style_bg_color(panel->LV_OBJ_IDX(node_tm2_idx), bg, LV_PART_MAIN | LV_STATE_DEFAULT);
                lv_obj_set_style_bg_opa(panel->LV_OBJ_IDX(node_tm2_idx), 255, LV_PART_MAIN | LV_STATE_DEFAULT);
                lv_obj_set_style_border_color(panel, bg, LV_PART_MAIN | LV_STATE_DEFAULT);
                lv_obj_set_style_border_width(panel, 2, LV_PART_MAIN | LV_STATE_DEFAULT);
                highlight = true;
            }
        }
        const char *name = lv_textarea_get_text(ui_NodesHLNameArea);
        if (name[0] != '\0') {
            if (strcasestr(lv_label_get_text(panel->LV_OBJ_IDX(node_lbl_idx)), name) ||
                strcasestr(lv_label_get_text(panel->LV_OBJ_IDX(node_lbs_idx)), name)) {
                lv_obj_set_style_border_color(panel, lv_color_hex(0x67EA94), LV_PART_MAIN | LV_STATE_DEFAULT);
                highlight = true;
            }
        }
    }
    if (!highlight) {
        lv_obj_set_style_border_color(panel, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_obj_set_style_border_width(panel, 1, LV_PART_MAIN | LV_STATE_DEFAULT);
    }
    return hide; // TODO || filter.active;
}

void TFTView_320x240::messageAlert(const char *alert, bool show)
{
    lv_label_set_text(objects.alert_label, alert);
    if (show)
        lv_obj_clear_flag(objects.alert_panel, LV_OBJ_FLAG_HIDDEN);
    else
        lv_obj_add_flag(objects.alert_panel, LV_OBJ_FLAG_HIDDEN);
}

/**
 * @brief mark the sent message as either heard or acknowledged
 *
 * @param channelOrNode
 * @param id
 * @param ack
 */
void TFTView_320x240::responseReceived(uint32_t channelOrNode, const uint32_t id, bool ack)
{
    lv_obj_t *msgContainer;
    if (channelOrNode < c_max_channels) {
        msgContainer = channelGroup[(uint8_t)channelOrNode];
        ack = true; // treat messages sent to group channel same as ack
    } else {
        msgContainer = messages[channelOrNode];
    }
    if (!msgContainer) {
        ILOG_WARN("received unexpected response nodeNum/channel 0x%08x for request id 0x%08x\n", channelOrNode, id);
        return;
    }
    // go through all hiddenPanels and search for requestId
    uint16_t i = msgContainer->spec_attr->child_cnt;
    while (i-- > 0) {
        lv_obj_t *panel = msgContainer->spec_attr->children[i];
        uint32_t requestId = (unsigned long)panel->user_data;
        if (requestId == id) {
            // now give the textlabel border another color
            lv_obj_t *textLabel = panel->spec_attr->children[0];
            lv_obj_set_style_border_color(textLabel, ack ? lv_color_hex(0x67EA94) : lv_color_hex(0xDBD251),
                                          LV_PART_MAIN | LV_STATE_DEFAULT);
            break;
        }
    }
}

void TFTView_320x240::packetReceived(const meshtastic_MeshPacket &p)
{
    MeshtasticView::packetReceived(p);
    // update time from packet
    if (p.rx_time > actTime) {
        actTime = p.rx_time;
    }
}

void TFTView_320x240::notifyResync(bool show)
{
    messageAlert("Resynch ...", show);
}

void TFTView_320x240::notifyReboot(bool show)
{
    messageAlert("Rebooting ...", show);
}

void TFTView_320x240::notifyShutdown(void)
{
    messageAlert("Shutting down ...", true);
}

void TFTView_320x240::blankScreen(bool enable)
{
    if (enable)
        lv_screen_load_anim(objects.blank_screen, LV_SCR_LOAD_ANIM_FADE_OUT, 1000, 0, false);
    else
        lv_screen_load_anim(objects.main_screen, LV_SCR_LOAD_ANIM_NONE, 0, 0, false);
}

void TFTView_320x240::updateChannelConfig(const meshtastic_Channel &ch)
{
    static lv_obj_t *btn[c_max_channels] = {objects.channel_button0, objects.channel_button1, objects.channel_button2,
                                            objects.channel_button3, objects.channel_button4, objects.channel_button5,
                                            objects.channel_button6, objects.channel_button7};
    db.channel[ch.index] = ch;

    if (ch.role != meshtastic_Channel_Role_DISABLED) {
        if (ch.role == meshtastic_Channel_Role_PRIMARY) {
            char buf[32];
            lv_snprintf(buf, sizeof(buf), "Channel: %s", strlen(ch.settings.name) ? ch.settings.name : "<no name>");
            lv_label_set_text(objects.basic_settings_channel_label, buf);
            lv_snprintf(buf, sizeof(buf), "*%s", strlen(ch.settings.name) ? ch.settings.name : "<no name>");
            lv_label_set_text(channel[ch.index], buf);
        } else {
            lv_label_set_text(channel[ch.index], ch.settings.name);
        }

        lv_obj_set_width(btn[ch.index], lv_pct(70));
        lv_obj_set_style_pad_left(btn[ch.index], 8, LV_PART_MAIN | LV_STATE_DEFAULT);

        lv_obj_t *lockImage = NULL;
        if (lv_obj_get_child_cnt(btn[ch.index]) == 1)
            lockImage = lv_img_create(btn[ch.index]);
        else
            lockImage = lv_obj_get_child(btn[ch.index], 1);

        uint32_t recolor = 0;

        if (memcmp(ch.settings.psk.bytes, "\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000", 16) == 0) {
            lv_img_set_src(lockImage, &img_groups_key_image);
            recolor = 0xF2E459; // yellow
        } else if (memcmp(ch.settings.psk.bytes, "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000", 16) == 0) {
            lv_img_set_src(lockImage, &img_groups_unlock_image);
            recolor = 0xF72B2B; // reddish
        } else {
            lv_img_set_src(lockImage, &img_groups_lock_image);
            recolor = 0x1EC174; // green
        }
        lv_obj_set_width(lockImage, LV_SIZE_CONTENT);  /// 1
        lv_obj_set_height(lockImage, LV_SIZE_CONTENT); /// 1
        lv_obj_set_align(lockImage, LV_ALIGN_LEFT_MID);
        lv_obj_add_flag(lockImage, LV_OBJ_FLAG_ADV_HITTEST);  /// Flags
        lv_obj_clear_flag(lockImage, LV_OBJ_FLAG_SCROLLABLE); /// Flags
        lv_obj_set_style_img_recolor(lockImage, lv_color_hex(recolor), LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_obj_set_style_img_recolor_opa(lockImage, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    } else {
        char buf[10];
        lv_snprintf(buf, sizeof(buf), "%d", ch.index);
        lv_label_set_text(channel[ch.index], buf);
        lv_obj_set_width(btn[ch.index], lv_pct(30));

        if (lv_obj_get_child_cnt(btn[ch.index]) == 2) {
            lv_obj_delete(lv_obj_get_child(btn[ch.index], 1));
        }
    }
}

void TFTView_320x240::updateDeviceConfig(const meshtastic_Config_DeviceConfig &cfg)
{
    db.config.device = cfg;
    db.config.has_device = true;
    char role[30];
    lv_snprintf(role, sizeof(role), "Device Role: %s", deviceRoleToString((eRole)cfg.role));
    lv_label_set_text(objects.basic_settings_role_label, role);
}

void TFTView_320x240::updatePositionConfig(const meshtastic_Config_PositionConfig &cfg)
{
    db.config.position = cfg;
    db.config.has_position = true;
}

void TFTView_320x240::updatePowerConfig(const meshtastic_Config_PowerConfig &cfg)
{
    db.config.power = cfg;
    db.config.has_power = true;
}

void TFTView_320x240::updateNetworkConfig(const meshtastic_Config_NetworkConfig &cfg)
{
    db.config.network = cfg;
    db.config.has_network = true;
}

void TFTView_320x240::updateDisplayConfig(const meshtastic_Config_DisplayConfig &cfg)
{
    db.config.display = cfg;
    db.config.has_display = true;
}

void TFTView_320x240::updateLoRaConfig(const meshtastic_Config_LoRaConfig &cfg)
{
    db.config.lora = cfg;
    db.config.has_lora = true;
    char region[30];
    lv_snprintf(region, sizeof(region), "Region: %s", LoRaPresets::loRaRegionToString(cfg.region));
    lv_label_set_text(objects.basic_settings_region_label, region);

    char preset[30];
    lv_snprintf(preset, sizeof(preset), "Modem Preset: %s", LoRaPresets::modemPresetToString(cfg.modem_preset));
    lv_label_set_text(objects.basic_settings_modem_preset_label, preset);

    uint32_t numChannels = LoRaPresets::getNumChannels(cfg.region, cfg.modem_preset);
    lv_slider_set_range(objects.frequency_slot_slider, 1, numChannels);

    if (!db.config.lora.channel_num) {
        db.config.lora.channel_num = LoRaPresets::getDefaultSlot(db.config.lora.region);
    }
    lv_slider_set_value(objects.frequency_slot_slider, db.config.lora.channel_num, LV_ANIM_OFF);
}

void TFTView_320x240::updateBluetoothConfig(const meshtastic_Config_BluetoothConfig &cfg)
{
    db.config.bluetooth = cfg;
    db.config.has_bluetooth = true;
}

/// ---- module updates ----

void TFTView_320x240::updateExtNotificationModule(const meshtastic_ModuleConfig_ExternalNotificationConfig &cfg)
{
    db.module_config.external_notification = cfg;
    db.module_config.has_external_notification = true;

    char buf[32];
    lv_snprintf(buf, sizeof(buf), "Message Alert: %s",
                db.module_config.external_notification.alert_message_buzzer && db.module_config.external_notification.enabled
                    ? "on"
                    : "off");
    lv_label_set_text(objects.basic_settings_alert_label, buf);
}

/**
 * @brief Create a new container for a node or group channel if it does not exist
 *
 * @param from
 * @param to: UINT32_MAX for broadcast, ownNode (= us) otherwise
 * @param channel
 */
lv_obj_t *TFTView_320x240::newMessageContainer(uint32_t from, uint32_t to, uint8_t ch)
{
    if (to == UINT32_MAX || from == 0) {
        if (channelGroup[ch] != nullptr)
            return channelGroup[ch];
    } else {
        if (messages[from] != nullptr)
            return messages[from];
    }

    // create container for new messages
    lv_obj_t *container = lv_obj_create(objects.messages_panel);
    lv_obj_remove_style_all(container);
    lv_obj_set_width(container, lv_pct(110));
    lv_obj_set_height(container, lv_pct(100));
    lv_obj_set_x(container, 0);
    lv_obj_set_y(container, -10);
    lv_obj_set_align(container, LV_ALIGN_TOP_MID);
    lv_obj_set_flex_flow(container, LV_FLEX_FLOW_COLUMN);
    lv_obj_set_flex_align(container, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START);
    lv_obj_clear_flag(container,
                      LV_OBJ_FLAG_PRESS_LOCK | LV_OBJ_FLAG_CLICK_FOCUSABLE | LV_OBJ_FLAG_GESTURE_BUBBLE | LV_OBJ_FLAG_SNAPPABLE |
                          LV_OBJ_FLAG_SCROLL_ELASTIC); /// Flags
    lv_obj_set_scrollbar_mode(container, LV_SCROLLBAR_MODE_ACTIVE);
    lv_obj_set_scroll_dir(container, LV_DIR_VER);
    lv_obj_set_style_pad_left(container, 6, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_right(container, 6, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_top(container, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_bottom(container, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_row(container, 6, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_column(container, 0, LV_PART_MAIN | LV_STATE_DEFAULT);

    // store new message container
    if (to == UINT32_MAX || from == 0) {
        channelGroup[ch] = container;
    } else {
        messages[from] = container;
    }

    // optionally add chat to chatPanel to access the container
    addChat(from, to, ch);

    return container;
}

/**
 * @brief insert a mew message that arrived into a <channel group> or <from node> container
 *
 * @param nodeNum
 * @param ch
 * @param msg
 */
void TFTView_320x240::newMessage(uint32_t from, uint32_t to, uint8_t ch, const char *msg)
{
    char buf[284]; // 237 + 4 + 40 + 2 + 1
    char *message = (char *)msg;
    lv_obj_t *container = nullptr;
    if (to == UINT32_MAX) { // message for group, prepend short name to msg
        sprintf(buf, "%s:\n%s", lv_label_get_text(nodes[from]->LV_OBJ_IDX(node_lbs_idx)), msg);
        message = buf;
        container = channelGroup[ch];
    } else { // message for us
        container = messages[from];
    }

    // if it's the first message we need a container
    if (!container) {
        container = newMessageContainer(from, to, ch);
    }

    // place new message into container
    newMessage(from, container, ch, message);

    // display msg popup if not already viewing the messages
    if (container != activeMsgContainer || activePanel != objects.messages_panel) {
        unreadMessages++;
        updateUnreadMessages();
        if (activePanel != objects.messages_panel) {
            showMessagePopup(from, to, ch, lv_label_get_text(nodes[from]->LV_OBJ_IDX(node_lbl_idx)));
        }
        lv_obj_add_flag(container, LV_OBJ_FLAG_HIDDEN);
    }

    highlightChat(from, to, ch);
}

/**
 * @brief Display message bubble in related message container
 *
 * @param nodeNum
 * @param container
 * @param ch
 * @param msg
 */
void TFTView_320x240::newMessage(uint32_t nodeNum, lv_obj_t *container, uint8_t ch, const char *msg)
{
    lv_obj_t *hiddenPanel = lv_obj_create(container);
    lv_obj_set_width(hiddenPanel, lv_pct(100));
    lv_obj_set_height(hiddenPanel, LV_SIZE_CONTENT); /// 50
    lv_obj_set_align(hiddenPanel, LV_ALIGN_CENTER);
    lv_obj_clear_flag(hiddenPanel, LV_OBJ_FLAG_SCROLLABLE); /// Flags
    lv_obj_set_style_radius(hiddenPanel, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(hiddenPanel, lv_color_hex(0x303030), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(hiddenPanel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_width(hiddenPanel, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_left(hiddenPanel, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_right(hiddenPanel, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_top(hiddenPanel, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_bottom(hiddenPanel, 0, LV_PART_MAIN | LV_STATE_DEFAULT);

    lv_obj_t *msgLabel = lv_label_create(hiddenPanel);
    // calculate expected size of text bubble, to make it look nicer
    lv_coord_t width = lv_txt_get_width(msg, strlen(msg), &ui_font_montserrat_12, 0);
    lv_obj_set_width(msgLabel, std::max(std::min(width + 20, 200), 40));
    lv_obj_set_height(msgLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_align(msgLabel, LV_ALIGN_LEFT_MID);
    lv_label_set_text(msgLabel, msg);
    lv_obj_set_style_text_color(msgLabel, lv_color_hex(0xD0D0D0), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_opa(msgLabel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(msgLabel, &ui_font_montserrat_12, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_radius(msgLabel, 10, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(msgLabel, lv_color_hex(0x404040), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(msgLabel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_color(msgLabel, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_opa(msgLabel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_width(msgLabel, 2, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_left(msgLabel, 8, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_right(msgLabel, 5, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_top(msgLabel, 1, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_bottom(msgLabel, 1, LV_PART_MAIN | LV_STATE_DEFAULT);

    lv_obj_scroll_to_view(hiddenPanel, LV_ANIM_ON);
}

/**
 * @brief Add a new chat to the chat panel to access the message container
 *
 * @param from
 * @param to
 * @param ch
 */
void TFTView_320x240::addChat(uint32_t from, uint32_t to, uint8_t ch)
{
    uint32_t index = ((to == UINT32_MAX || from == 0) ? ch : from);
    auto it = chats.find(index);
    if (it != chats.end())
        return;

    lv_obj_t *chatDelBtn = nullptr;
    lv_obj_t *parent_obj = objects.chats_panel;

    // ChatsButton
    lv_obj_t *chatBtn = lv_btn_create(parent_obj);
    lv_obj_set_pos(chatBtn, 0, 0);
    lv_obj_set_size(chatBtn, LV_PCT(100), 36);
    lv_obj_add_flag(chatBtn, LV_OBJ_FLAG_SCROLL_ON_FOCUS);
    lv_obj_clear_flag(chatBtn, LV_OBJ_FLAG_SCROLLABLE);
    lv_obj_set_style_align(chatBtn, LV_ALIGN_TOP_MID, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(chatBtn, lv_color_hex(0xff404040), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_color(chatBtn, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_width(chatBtn, 1, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_shadow_ofs_x(chatBtn, 1, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_shadow_ofs_y(chatBtn, 2, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_radius(chatBtn, 6, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_left(chatBtn, 3, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_right(chatBtn, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_top(chatBtn, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_bottom(chatBtn, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_row(chatBtn, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_column(chatBtn, 0, LV_PART_MAIN | LV_STATE_DEFAULT);

    char buf[64];
    if (to == UINT32_MAX || from == 0) {
        sprintf(buf, "%d: %s", (int)ch, lv_label_get_text(channel[ch]));
    } else {
        sprintf(buf, "%s: %s", lv_label_get_text(nodes[from]->LV_OBJ_IDX(node_lbs_idx)),
                lv_label_get_text(nodes[from]->LV_OBJ_IDX(node_lbl_idx)));
    }

    {
        lv_obj_t *parent_obj = chatBtn;
        {
            // ChatsButtonLabel
            lv_obj_t *obj = lv_label_create(parent_obj);
            objects.chats_button_label = obj;
            lv_obj_set_pos(obj, 0, 0);
            lv_obj_set_size(obj, LV_PCT(100), LV_SIZE_CONTENT);
            lv_label_set_long_mode(obj, LV_LABEL_LONG_DOT);
            lv_label_set_text(obj, buf);
            lv_obj_set_style_align(obj, LV_ALIGN_LEFT_MID, LV_PART_MAIN | LV_STATE_DEFAULT);
            lv_obj_set_style_text_align(obj, LV_TEXT_ALIGN_LEFT, LV_PART_MAIN | LV_STATE_DEFAULT);
            lv_obj_set_style_text_font(obj, &ui_font_montserrat_14, LV_PART_MAIN | LV_STATE_DEFAULT);
        }
        {
            // ChatDelButton
            lv_obj_t *obj = lv_btn_create(parent_obj);
            chatDelBtn = obj;
            lv_obj_set_pos(obj, -3, -1);
            lv_obj_set_size(obj, 40, 23);
            lv_obj_add_flag(obj, LV_OBJ_FLAG_SCROLL_ON_FOCUS);
            lv_obj_clear_flag(obj, LV_OBJ_FLAG_SCROLLABLE);
            lv_obj_set_style_align(obj, LV_ALIGN_RIGHT_MID, LV_PART_MAIN | LV_STATE_DEFAULT);
            lv_obj_set_style_bg_color(obj, lv_color_hex(0xffa70a0a), LV_PART_MAIN | LV_STATE_DEFAULT);
            lv_obj_add_flag(chatDelBtn, LV_OBJ_FLAG_HIDDEN);
            lv_obj_clear_flag(chatDelBtn, LV_OBJ_FLAG_SCROLLABLE);
            lv_obj_set_style_bg_opa(chatDelBtn, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
            {
                lv_obj_t *parent_obj = obj;
                {
                    // DelLabel
                    lv_obj_t *chatDelBtn = lv_label_create(parent_obj);
                    lv_obj_set_pos(chatDelBtn, 0, 0);
                    lv_obj_set_size(chatDelBtn, LV_SIZE_CONTENT, LV_SIZE_CONTENT);
                    lv_label_set_text(chatDelBtn, "DEL");
                    lv_obj_set_style_align(chatDelBtn, LV_ALIGN_CENTER, LV_PART_MAIN | LV_STATE_DEFAULT);
                }
            }
        }
    }

    chats[index] = chatBtn;
    updateActiveChats();
    if (index > c_max_channels)
        applyNodesFilter(index);

    lv_obj_add_event_cb(chatBtn, ui_event_ChatButton, LV_EVENT_ALL, (void *)index);
    lv_obj_add_event_cb(chatDelBtn, ui_event_ChatDelButton, LV_EVENT_CLICKED, (void *)index);
}

void TFTView_320x240::highlightChat(uint32_t from, uint32_t to, uint8_t ch)
{
    uint32_t index = ((to == UINT32_MAX || from == 0) ? ch : from);
    auto it = chats.find(index);
    if (it != chats.end()) {
        // mark chat in color
        lv_obj_set_style_border_color(it->second, lv_color_hex(0xFF8C04), LV_PART_MAIN | LV_STATE_DEFAULT);
    }
}

void TFTView_320x240::updateActiveChats(void)
{
    char buf[20];
    sprintf(buf, "%d active chat(s)", chats.size());
    lv_label_set_text(objects.top_chats_label, buf);
}

/**
 * @brief display new message popup panel
 *
 * @param from sender (NULL for removing popup)
 * @param to individual or group message
 * @param ch received channel
 */
void TFTView_320x240::showMessagePopup(uint32_t from, uint32_t to, uint8_t ch, const char *name)
{
    if (name) {
        static char buf[64];
        sprintf(buf, "New message from \n%s", name);
        buf[38] = '\0'; // cut too long userName
        lv_label_set_text(objects.msg_popup_label, buf);
        if (to == UINT32_MAX)
            objects.msg_popup_button->user_data = (void *)(uint32_t)ch; // store the channel in the button's data
        else
            objects.msg_popup_button->user_data = (void *)from; // store the node in the button's data
        lv_obj_clear_flag(objects.msg_popup_panel, LV_OBJ_FLAG_HIDDEN);

        if (db.module_config.external_notification.alert_message)
            lv_disp_trig_activity(NULL);
    }
}

void TFTView_320x240::hideMessagePopup(void)
{
    lv_obj_add_flag(objects.msg_popup_panel, LV_OBJ_FLAG_HIDDEN);
}

/**
 * @brief Display messages of a group channel
 *
 * @param ch
 */
void TFTView_320x240::showMessages(uint8_t ch)
{
    lv_obj_add_flag(activeMsgContainer, LV_OBJ_FLAG_HIDDEN);
    activeMsgContainer = channelGroup[ch];
    if (!activeMsgContainer) {
        activeMsgContainer = newMessageContainer(0, UINT32_MAX, ch);
    }

    activeMsgContainer->user_data = (void *)(uint32_t)ch;
    lv_obj_clear_flag(activeMsgContainer, LV_OBJ_FLAG_HIDDEN);
    lv_label_set_text(objects.top_group_chat_label, lv_label_get_text(channel[ch]));
    ui_set_active(objects.messages_button, objects.messages_panel, objects.top_group_chat_panel);
}

/**
 * @brief Display messages from a node
 *
 * @param nodeNum
 */
void TFTView_320x240::showMessages(uint32_t nodeNum)
{
    lv_obj_add_flag(activeMsgContainer, LV_OBJ_FLAG_HIDDEN);
    activeMsgContainer = messages[nodeNum];
    if (!activeMsgContainer) {
        activeMsgContainer = newMessageContainer(nodeNum, 0, 0);
    }
    activeMsgContainer->user_data = (void *)nodeNum;
    lv_obj_clear_flag(activeMsgContainer, LV_OBJ_FLAG_HIDDEN);
    lv_obj_t *p = nodes[nodeNum];
    if (p) {
        lv_label_set_text(objects.top_messages_node_label, lv_label_get_text(p->LV_OBJ_IDX(node_lbl_idx)));
        ui_set_active(objects.messages_button, objects.messages_panel, objects.top_messages_panel);
        unreadMessages = 0; // TODO: not all messages may be actually read
        updateUnreadMessages();
    } else {
        // TODO: log error
    }
}

/**
 * @brief Place keyboard at a suitable space above or below the text input area
 *
 * @param textArea
 */
void TFTView_320x240::showKeyboard(lv_obj_t *textArea)
{
    lv_area_t text_coords, kb_coords;
    lv_obj_get_coords(textArea, &text_coords);
    lv_obj_get_coords(objects.keyboard, &kb_coords);
    uint32_t kb_h = kb_coords.y2 - kb_coords.y1;
    uint32_t v = lv_display_get_vertical_resolution(displaydriver->getDisplay());

    if (text_coords.y1 > kb_h + 30) {
        // if enough place above put under top panel
        lv_obj_set_pos(objects.keyboard, 0, 28);
    } else if ((text_coords.y1 + 10) > v / 2) {
        // if text area is at lower half then place above text area
        lv_obj_set_pos(objects.keyboard, 0, text_coords.y1 - kb_h - 2);
    } else {
        // place below text area
        lv_obj_set_pos(objects.keyboard, 0, text_coords.y2 + 3);
    }

    lv_keyboard_set_textarea(objects.keyboard, textArea);
}

/**
 * input group for all widgets to be used by keyboard and/or pointer
 */
void TFTView_320x240::setInputGroup(void)
{
    if (input_group)
        lv_group_delete(input_group);

    input_group = lv_group_create();
    lv_group_set_default(input_group);

    if (inputdriver->hasKeyboardDevice())
        lv_indev_set_group(inputdriver->getKeyboard(), input_group);

    if (inputdriver->hasPointerDevice())
        lv_indev_set_group(inputdriver->getPointer(), input_group);

    // connect keyboard and pointer with all message text areas
    lv_group_add_obj(input_group, objects.message_input_area);
    lv_group_add_obj(input_group, objects.settings_user_short_textarea);
    lv_group_add_obj(input_group, objects.settings_user_long_textarea);
    lv_group_add_obj(input_group, objects.settings_modify_channel_name_textarea);
    lv_group_add_obj(input_group, objects.settings_modify_channel_psk_textarea);
    lv_group_add_obj(input_group, ui_NodesFilterNameArea);
    lv_group_add_obj(input_group, ui_NodesHLNameArea);
}

void TFTView_320x240::setInputButtonLabel(void)
{
    // update input button label
    std::string current_kbd = inputdriver->getCurrentKeyboardDevice();
    std::string current_ptr = inputdriver->getCurrentPointerDevice();

    char label[40];
    lv_snprintf(label, sizeof(label), "Input Control: %s/%s", current_ptr.c_str(), current_kbd.c_str());
    lv_label_set_text(objects.basic_settings_input_label, label);
}
// -------- helpers --------

void TFTView_320x240::removeNode(uint32_t nodeNum)
{
    auto it = nodes.find(nodeNum);
    if (it != nodes.end()) {
    }
}

void TFTView_320x240::setNodeImage(uint32_t nodeNum, eRole role, bool viaMqtt, lv_obj_t *img)
{
    uint32_t bgColor, fgColor;
    std::tie(bgColor, fgColor) = nodeColor(nodeNum);
    // if (viaMqtt) {
    //     lv_img_set_src(img, &//TODO );
    // }
    // else
    switch (role) {
    case client:
    case client_mute:
    case client_hidden:
    case tak: {
        lv_img_set_src(img, &img_node_client_image);
        break;
    }
    case router_client: {
        lv_img_set_src(img, &img_top_nodes_image);
        break;
    }
    case repeater:
    case router: {
        lv_img_set_src(img, &img_node_router_image);
        break;
    }
    case tracker:
    case sensor:
    case lost_and_found:
    case tak_tracker: {
        lv_img_set_src(img, &img_node_sensor_image);
        break;
    }
    case unknown: {
        lv_img_set_src(img, &img_circle_question_image);
        break;
    }
    default:
        lv_img_set_src(img, &img_node_client_image);
        break;
    }

    lv_obj_set_style_bg_color(img, lv_color_hex(bgColor), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_color(img, lv_color_hex(bgColor), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_img_recolor_opa(img, fgColor ? 0 : 255, LV_PART_MAIN | LV_STATE_DEFAULT);
}

void TFTView_320x240::updateNodesStatus(void)
{
    char buf[32];
    lv_snprintf(buf, sizeof(buf), "%d of %d nodes online", nodesOnline, nodeCount);
    lv_label_set_text(objects.home_nodes_label, buf);

    if (nodesFiltered) {
        if (processingFilter)
            lv_snprintf(buf, sizeof(buf), "Filtering ...");
        else
            lv_snprintf(buf, sizeof(buf), "Filter: %d of %d nodes", nodeCount - nodesFiltered, nodeCount);
    }
    lv_label_set_text(objects.top_nodes_online_label, buf);
}

/**
 * @brief Dynamically update all nodes filter and highlight
 *        Because the update can take quite some time (tens of ms) it is done in smaller
 *        chunks of 10 nodes per invocation, so it must be periodically called
 *        TODO: check for side effects if new nodes are inserted during filter processing
 * @param reset indicates to start update from beginning of node list otherwise
 *        continue with iterator position or skip if done
 */
void TFTView_320x240::updateNodesFiltered(bool reset)
{
    static auto it = nodes.begin();
    if (reset) {
        nodesFiltered = 0;
        processingFilter = true;
        it = nodes.begin();
    }

    for (int i = 0; i < 10 && it != nodes.end(); i++) {
        applyNodesFilter(it->first, true);
        it++;
    }

    if (it == nodes.end()) {
        processingFilter = false;
        updateNodesStatus();
    }
}

/**
 * @brief Update last heard display/user_data/counter to current time
 *
 * @param nodeNum
 */
void TFTView_320x240::updateLastHeard(uint32_t nodeNum)
{
    time_t curtime;
    time(&curtime);
    auto it = nodes.find(nodeNum);
    if (it != nodes.end()) {
        time_t lastHeard = (time_t)it->second->LV_OBJ_IDX(node_lh_idx)->user_data;
        it->second->LV_OBJ_IDX(node_lh_idx)->user_data = (void *)curtime;
        lv_label_set_text(it->second->LV_OBJ_IDX(node_lh_idx), "now");
        if (it->first != ownNode) {
            if (curtime - lastHeard + 10 >= 900) {
                nodesOnline++;
                applyNodesFilter(nodeNum);
                updateNodesStatus();
            }
            // move to top position
            lv_obj_move_to_index(it->second, 1);
        }
    }
}

/**
 * @brief update last heard display for all nodes; also update nodes online
 *
 */
void TFTView_320x240::updateAllLastHeard(void)
{
    uint16_t online = 0;
    time_t lastHeard;
    for (auto &it : nodes) {
        char buf[20];
        if (it.first == ownNode) { // own node is always now, so do update
            time_t curtime;
            time(&curtime);
            lastHeard = curtime;
            it.second->LV_OBJ_IDX(node_lh_idx)->user_data = (void *)lastHeard;
        } else {
            lastHeard = (time_t)it.second->LV_OBJ_IDX(node_lh_idx)->user_data;
        }
        if (lastHeard) {
            bool isOnline = lastHeartToString(lastHeard, buf);
            lv_label_set_text(it.second->LV_OBJ_IDX(node_lh_idx), buf);
            if (isOnline)
                online++;
        }
    }
    nodesOnline = online;
    updateNodesFiltered(true);
    updateNodesStatus();
}

void TFTView_320x240::updateUnreadMessages(void)
{
    char buf[20];
    if (unreadMessages > 0) {
        sprintf(buf, unreadMessages == 1 ? "%d new message" : "%d new messages", unreadMessages);
        lv_obj_set_style_bg_img_src(objects.home_mail_button, &img_home_mail_unread_button_image,
                                    LV_PART_MAIN | LV_STATE_DEFAULT);
    } else {
        strcpy(buf, "no new messages");
        lv_obj_set_style_bg_img_src(objects.home_mail_button, &img_home_mail_button_image, LV_PART_MAIN | LV_STATE_DEFAULT);
    }
    lv_label_set_text(objects.home_mail_label, buf);
}

/**
 * @brief Called once a second to update time label
 *
 */
void TFTView_320x240::updateTime(void)
{
    char buf[64];
    time_t curr_time;
#ifdef ARCH_PORTDUINO
    time(&curr_time);
#else
    curr_time = actTime;
#endif
    tm *curr_tm = gmtime(&curr_time);

    int len = 0;
    if (curr_time > 1000000) {
        len = strftime(buf, 40, "%T GMT\n%a %d-%b-%g", curr_tm);
    } else {
        uint32_t uptime = millis() / 1000;
        int hours = uptime / 3600;
        uptime -= hours * 3600;
        int minutes = uptime / 60;
        int seconds = uptime - minutes * 60;

        sprintf(&buf[len], "%02d:%02d:%02d uptime", hours, minutes, seconds);
    }
    lv_label_set_text(objects.home_time_label, buf);
}

void TFTView_320x240::updateFreeMem(void)
{
    // only update if HomePanel is active (since this is some critical code that did crash sporadically)
    if (activePanel == objects.home_panel && (unsigned long)objects.home_memory_button->user_data) {
        char buf[64];
        uint32_t freeHeap = 0;
        uint32_t freeHeap_pct = 100;
#ifdef ARDUINO_ARCH_ESP32
        freeHeap = ESP.getFreeHeap();
        freeHeap_pct = 100 * freeHeap / ESP.getHeapSize();
#endif

        lv_mem_monitor_t mon;
        lv_mem_monitor(&mon);
        sprintf(buf, "Heap: %d (%d%%)\nLVGL: %d (%d%%)", freeHeap, freeHeap_pct, mon.free_size, 100 - mon.used_pct);
        lv_label_set_text(objects.home_memory_label, buf);
    }
}

void TFTView_320x240::task_handler(void)
{
    MeshtasticView::task_handler();

    time_t curtime;
    time(&curtime);
    if (curtime - lastrun1 >= 1) { // call every 1s
        lastrun1 = curtime;
        actTime++;
        updateTime();
    }
    if (curtime - lastrun5 >= 5) { // call every 5s
        lastrun5 = curtime;
        updateFreeMem();
    }
    if (curtime - lastrun60 >= 60) { // call every 60s
        lastrun60 = curtime;
        updateAllLastHeard();
    }

    if (processingFilter) {
        updateNodesFiltered(false);
    }
}

// === lvgl C style callbacks ===

extern "C" {

void action_on_boot_screen_displayed(lv_event_t *e)
{
    ILOG_DEBUG("action_on_boot_screen_displayed()\n");
}
}

#endif