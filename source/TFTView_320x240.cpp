#if HAS_TFT // VIEW_320x240

#include "TFTView_320x240.h"
#include "Arduino.h"
#include "DisplayDriverFactory.h"
#include "ILog.h"
#include "ViewController.h"
#include "images.h"
#include "ui.h" // this is the ui generated by eez-studio
#include <algorithm>
#include <cstdio>
#include <functional>
#include <math.h>

#define CR_REPLACEMENT 0x0C // dummy to record several lines in a one line textarea

// children index of nodepanel lv objects (see addNode)
enum NodePanelIdx { node_img_idx, node_btn_idx, node_lbl_idx, node_lbs_idx, node_bat_idx, node_lh_idx, node_sig_idx };

TFTView_320x240 *TFTView_320x240::gui = nullptr;

TFTView_320x240 *TFTView_320x240::instance(void)
{
    if (!gui) {
        gui = new TFTView_320x240(DisplayDriverFactory::create(320, 240));
    }
    return gui;
}

TFTView_320x240 *TFTView_320x240::instance(const DisplayDriverConfig &cfg)
{
    if (!gui) {
        gui = new TFTView_320x240(DisplayDriverFactory::create(cfg));
    }
    return gui;
}

TFTView_320x240::TFTView_320x240(DisplayDriver *driver) : MeshtasticView(driver, new ViewController) {}

void TFTView_320x240::init(IClientBase *client)
{
    ILOG_DEBUG("TFTView_320x240 init...\n");
    MeshtasticView::init(client);
    time(&lastrun60);
    time(&lastrun5);

    activeMsgContainer = objects.messages_container;
    channel = {// TODO: channel is intended to store all channel data, not just the name(label)
               objects.channel_label0, objects.channel_label1, objects.channel_label2, objects.channel_label3,
               objects.channel_label4, objects.channel_label5, objects.channel_label6, objects.channel_label7};
    channelGroup = {nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr};
    ui_set_active(objects.home_button, objects.home_panel, objects.top_panel);
    ui_events_init();

    // keyboard init
    lv_keyboard_set_textarea(objects.keyboard, objects.message_input_area);
}

/**
 * @brief set active button, panel and top panel
 *
 * @param b button to set active
 * @param p main panel to set active
 * @param tp top panel to set active
 */
void TFTView_320x240::ui_set_active(lv_obj_t *b, lv_obj_t *p, lv_obj_t *tp)
{
    if (activeButton) {
        lv_obj_set_style_border_width(activeButton, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_obj_set_style_bg_img_recolor_opa(activeButton, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    }
    lv_obj_set_style_border_width(b, 3, LV_PART_MAIN | LV_STATE_DEFAULT);
    // lv_obj_set_style_bg_img_recolor(b, lv_color_hex(0x67EA94), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_img_recolor_opa(b, 255, LV_PART_MAIN | LV_STATE_DEFAULT);

    if (activePanel) {
        lv_obj_add_flag(activePanel, LV_OBJ_FLAG_HIDDEN);
        if (activePanel == objects.messages_panel) {
            unreadMessages = 0; // TODO: not all messages may be actually read
            updateUnreadMessages();
        }
    }

    lv_obj_clear_flag(p, LV_OBJ_FLAG_HIDDEN);

    if (tp) {
        if (activeTopPanel) {
            lv_obj_add_flag(activeTopPanel, LV_OBJ_FLAG_HIDDEN);
        }
        lv_obj_clear_flag(tp, LV_OBJ_FLAG_HIDDEN);
        activeTopPanel = tp;
    }

    activeButton = b;
    activePanel = p;

    lv_obj_clear_flag(objects.keyboard, LV_OBJ_FLAG_HIDDEN);
    lv_obj_add_flag(objects.msg_popup_panel, LV_OBJ_FLAG_HIDDEN);
}

void TFTView_320x240::ui_events_init(void)
{
    // just a test to implement callback via non-static lambda function
    auto ui_event_HomeButton = [](lv_event_t *e) {
        lv_event_code_t event_code = lv_event_get_code(e);
        if (event_code == LV_EVENT_CLICKED) {
            TFTView_320x240 &view = *static_cast<TFTView_320x240 *>(e->user_data);
            view.ui_set_active(objects.home_button, objects.home_panel, objects.top_panel);
        } else if (event_code == LV_EVENT_LONG_PRESSED) {
            // force re-sync with node
            TFTView_320x240::instance()->controller->setConfigRequested(true);
        }
    };

    // main button events
    lv_obj_add_event_cb(objects.home_button, ui_event_HomeButton, LV_EVENT_ALL, this); // uses lambda above
    lv_obj_add_event_cb(objects.nodes_button, this->ui_event_NodesButton, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(objects.groups_button, this->ui_event_GroupsButton, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(objects.messages_button, this->ui_event_MessagesButton, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(objects.map_button, this->ui_event_MapButton, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(objects.settings_button, this->ui_event_SettingsButton, LV_EVENT_ALL, NULL);

    // node and channel buttons
    lv_obj_add_event_cb(objects.node_button, ui_event_NodeButtonClicked, LV_EVENT_ALL, (void *)ownNode);

    // 8 channel buttons
    lv_obj_add_event_cb(objects.channel_button0, ui_event_ChannelButtonClicked, LV_EVENT_ALL, (void *)0);
    lv_obj_add_event_cb(objects.channel_button1, ui_event_ChannelButtonClicked, LV_EVENT_ALL, (void *)1);
    lv_obj_add_event_cb(objects.channel_button2, ui_event_ChannelButtonClicked, LV_EVENT_ALL, (void *)2);
    lv_obj_add_event_cb(objects.channel_button3, ui_event_ChannelButtonClicked, LV_EVENT_ALL, (void *)3);
    lv_obj_add_event_cb(objects.channel_button4, ui_event_ChannelButtonClicked, LV_EVENT_ALL, (void *)4);
    lv_obj_add_event_cb(objects.channel_button5, ui_event_ChannelButtonClicked, LV_EVENT_ALL, (void *)5);
    lv_obj_add_event_cb(objects.channel_button6, ui_event_ChannelButtonClicked, LV_EVENT_ALL, (void *)6);
    lv_obj_add_event_cb(objects.channel_button7, ui_event_ChannelButtonClicked, LV_EVENT_ALL, (void *)7);

    // new message popup
    lv_obj_add_event_cb(objects.msg_popup_button, this->ui_event_MsgPopupButton, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(objects.msg_popup_panel, this->ui_event_MsgPopupButton, LV_EVENT_ALL, NULL);

    // keyboard
    lv_obj_add_event_cb(objects.keyboard, ui_event_Keyboard, LV_EVENT_ALL, this);
}

#if 0 // defined above as lambda function for tests
void TDeckGUI::ui_event_HomeButton(lv_event_t * e) {
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED) {
        TDeckGUI::instance()->ui_set_active(objects.home_button, objects.home_panel, objects.top_panel);
    }
}
#endif

void TFTView_320x240::ui_event_NodesButton(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED) {
        TFTView_320x240::instance()->ui_set_active(objects.nodes_button, objects.nodes_panel, objects.top_nodes_panel);
    }
}

void TFTView_320x240::ui_event_NodeButtonClicked(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_LONG_PRESSED) {
        //  set color and text of clicked node
        uint32_t nodeNum = (unsigned long)e->user_data;
        if (nodeNum != TFTView_320x240::instance()->ownNode)
            TFTView_320x240::instance()->showMessages(nodeNum);
    }
}

void TFTView_320x240::ui_event_GroupsButton(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED) {
        TFTView_320x240::instance()->ui_set_active(objects.groups_button, objects.groups_panel, objects.top_groups_panel);
    }
}

void TFTView_320x240::ui_event_ChannelButtonClicked(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED) {
        // set color and text of clicked group channel
        uint8_t ch = (uint8_t)(unsigned long)e->user_data;
        if (TFTView_320x240::instance()->channelGroup[ch]) {
            TFTView_320x240::instance()->showMessages(ch);
        } else {
            // TODO: click on unset channel should popup config screen
        }
    }
}

void TFTView_320x240::ui_event_MessagesButton(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED) {
        TFTView_320x240::instance()->ui_set_active(objects.messages_button, objects.messages_panel, objects.top_chats_panel);
    }
}

void TFTView_320x240::ui_event_MapButton(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED) {
        TFTView_320x240::instance()->ui_set_active(objects.map_button, objects.map_panel, objects.top_map_label);
    }
}

void TFTView_320x240::ui_event_SettingsButton(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED) {
        TFTView_320x240::instance()->ui_set_active(objects.settings_button, objects.settings_panel, objects.top_settings_panel);
    }
}

void TFTView_320x240::ui_event_ChatButtonClicked(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t *target = lv_event_get_target_obj(e);
    if (event_code == LV_EVENT_LONG_PRESSED) {
        lv_obj_t *delBtn = target->LV_OBJ_IDX(1);
        lv_obj_clear_flag(delBtn, LV_OBJ_FLAG_HIDDEN);
    } else if (event_code == LV_EVENT_DEFOCUSED || event_code == LV_EVENT_RELEASED || event_code == LV_EVENT_PRESS_LOST) {
        lv_obj_t *delBtn = target->LV_OBJ_IDX(1);
        lv_obj_add_flag(delBtn, LV_OBJ_FLAG_HIDDEN);
    } else if (event_code == LV_EVENT_CLICKED) {
        lv_obj_set_style_border_color(target, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);

        uint32_t channelOrNode = (unsigned long)e->user_data;
        if (channelOrNode < c_max_channels) {
            uint8_t ch = (uint8_t)channelOrNode;
            TFTView_320x240::instance()->showMessages(ch);
            TFTView_320x240::instance()->ui_set_active(objects.messages_button, objects.messages_panel,
                                                       objects.top_group_chat_panel);
        } else {
            uint32_t nodeNum = channelOrNode;
            TFTView_320x240::instance()->showMessages(nodeNum);
            TFTView_320x240::instance()->ui_set_active(objects.messages_button, objects.messages_panel,
                                                       objects.top_messages_panel);
        }
    }
}

/**
 * @brief Del button pressed, handle deletion or clearance of chat and messages panel
 *
 * @param e
 */
void TFTView_320x240::ui_event_ChatDelButtonClicked(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED) {
        lv_obj_t *target = lv_event_get_target_obj(e);
        lv_obj_add_flag(target, LV_OBJ_FLAG_HIDDEN);

        uint32_t channelOrNode = (unsigned long)e->user_data;
        if (channelOrNode < c_max_channels) {
            uint8_t ch = (uint8_t)channelOrNode;
            lv_obj_clean(TFTView_320x240::instance()->channelGroup[ch]);
        } else {
            uint32_t nodeNum = channelOrNode;
            lv_obj_delete_delayed(TFTView_320x240::instance()->chats[nodeNum], 500);
            lv_obj_del(TFTView_320x240::instance()->messages[nodeNum]);
            TFTView_320x240::instance()->chats.erase(nodeNum);
            TFTView_320x240::instance()->messages.erase(nodeNum);
            TFTView_320x240::instance()->activeMsgContainer = objects.messages_container;
            TFTView_320x240::instance()->updateActiveChats();
        }
    }
}

/**
 * @brief hide msgPopupPanel on touch; goto message on button press
 *
 */
void TFTView_320x240::ui_event_MsgPopupButton(lv_event_t *e)
{
    lv_obj_t *target = lv_event_get_target_obj(e);
    lv_event_code_t event_code = lv_event_get_code(e);
    if (target == objects.msg_popup_panel) {
        if (event_code == LV_EVENT_PRESSED) {
            TFTView_320x240::instance()->hideMessagePopup();
        }
    } else { // msg button was clicked
        if (event_code == LV_EVENT_CLICKED) {
            uint32_t channelOrNode = (unsigned long)objects.msg_popup_button->user_data;
            if (channelOrNode < c_max_channels) {
                uint8_t ch = (uint8_t)channelOrNode;
                TFTView_320x240::instance()->showMessages(ch);
            } else {
                uint32_t nodeNum = channelOrNode;
                TFTView_320x240::instance()->showMessages(nodeNum);
            }
        }
    }
}

void TFTView_320x240::ui_event_Keyboard(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED) {
        lv_obj_t *kb = lv_event_get_target_obj(e);
        uint32_t btn_id = lv_keyboard_get_selected_button(kb);

        switch (btn_id) {
        case 22: { // enter (filtered out by one-liner text input area, so we replace it)
            lv_obj_t *ta = lv_keyboard_get_textarea(kb);
            lv_textarea_add_char(ta, ' ');
            lv_textarea_add_char(ta, CR_REPLACEMENT);
            break;
        }
        case 35: { // keyboard
            lv_keyboard_set_popovers(objects.keyboard, !lv_buttonmatrix_get_popovers(kb));
            break;
        }
        case 36: { // left
            break;
        }
        case 38: { // right
            break;
        }
        case 39: { // checkmark
            lv_obj_t *ta = lv_keyboard_get_textarea(kb);
            char *txt = (char *)lv_textarea_get_text(ta);
            lv_obj_add_flag(kb, LV_OBJ_FLAG_HIDDEN);
            if (ta == objects.message_input_area) {
                TFTView_320x240::instance()->handleAddMessage(txt);
            }
            lv_textarea_set_text(ta, "");
            break;
        }
        default:
            const char *txt = lv_keyboard_get_button_text(kb, btn_id);
        }
    }
}

void TFTView_320x240::handleAddMessage(char *msg)
{
    // retrieve nodeNum + channel from activeMsgContainer
    uint8_t ch;
    uint32_t to = UINT32_MAX;
    uint32_t channelOrNode = (unsigned long)activeMsgContainer->user_data;
    if (channelOrNode < c_max_channels) {
        ch = (uint8_t)channelOrNode;
    } else {
        ch = (uint8_t)(unsigned long)nodes[channelOrNode]->user_data;
        to = channelOrNode;
    }

    controller->sendText(to, ch, msg);
    addMessage(msg);
}

void TFTView_320x240::addMessage(char *msg)
{
    lv_obj_t *hiddenPanel = lv_obj_create(activeMsgContainer);
    lv_obj_set_width(hiddenPanel, lv_pct(100));
    lv_obj_set_height(hiddenPanel, LV_SIZE_CONTENT);
    lv_obj_set_align(hiddenPanel, LV_ALIGN_CENTER);
    lv_obj_clear_flag(hiddenPanel, LV_OBJ_FLAG_SCROLLABLE);
    lv_obj_set_style_radius(hiddenPanel, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(hiddenPanel, lv_color_hex(0x303030), LV_PART_MAIN | LV_STATE_DEFAULT);
    // lv_obj_set_style_bg_opa(hiddenPanel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_width(hiddenPanel, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_left(hiddenPanel, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_right(hiddenPanel, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_top(hiddenPanel, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_bottom(hiddenPanel, 0, LV_PART_MAIN | LV_STATE_DEFAULT);

    lv_obj_t *textLabel = lv_label_create(hiddenPanel);
    // calculate expected size of text bubble, to make it look nicer
    lv_coord_t width = lv_txt_get_width(msg, strlen(msg), &lv_font_montserrat_12, 0);
    lv_obj_set_width(textLabel, std::max(std::min(width + 20, 200), 40));
    lv_obj_set_height(textLabel, LV_SIZE_CONTENT);
    lv_obj_set_y(textLabel, 0);
    lv_obj_set_align(textLabel, LV_ALIGN_RIGHT_MID);

    // tweak to allow multiple lines in single line text area
    for (int i = 0; i < strlen(msg); i++)
        if (msg[i] == CR_REPLACEMENT)
            msg[i] = '\n';
    lv_label_set_text(textLabel, msg);
    lv_obj_set_style_text_color(textLabel, lv_color_hex(0xF0F0F0), LV_PART_MAIN | LV_STATE_DEFAULT);
    // lv_obj_set_style_text_opa(textLabel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_align(textLabel, LV_TEXT_ALIGN_LEFT, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(textLabel, &lv_font_montserrat_12, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_radius(textLabel, 10, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(textLabel, lv_color_hex(0x404040), LV_PART_MAIN | LV_STATE_DEFAULT);
    // lv_obj_set_style_bg_opa(textLabel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_color(textLabel, lv_color_hex(0x67EA94), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_opa(textLabel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_width(textLabel, 2, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_left(textLabel, 8, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_right(textLabel, 5, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_top(textLabel, 1, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_bottom(textLabel, 1, LV_PART_MAIN | LV_STATE_DEFAULT);

    lv_obj_scroll_to_view(hiddenPanel, LV_ANIM_ON);
}

void TFTView_320x240::addNode(uint32_t nodeNum, uint8_t ch, const char *userShort, const char *userLong, uint32_t lastHeard,
                              eRole role)
{
    // lv_obj nodesPanel children
    // [0]: img
    // [1]: btn
    // [2]: lbl user long
    // [3]: lbl user short
    // [4]: lbl battery
    // [5]: lbl lastHeard
    // [6]: lbl signal
    // user_data: ch

    lv_obj_t *p = lv_obj_create(objects.nodes_panel);
    p->user_data = (void *)(uint32_t)ch;
    nodes[nodeNum] = p;
    nodeCount++;

    lv_obj_set_height(p, 50);
    lv_obj_set_width(p, lv_pct(100));
    lv_obj_set_align(p, LV_ALIGN_CENTER);
    lv_obj_clear_flag(p, LV_OBJ_FLAG_CLICKABLE | LV_OBJ_FLAG_PRESS_LOCK | LV_OBJ_FLAG_CLICK_FOCUSABLE |
                             LV_OBJ_FLAG_GESTURE_BUBBLE | LV_OBJ_FLAG_SNAPPABLE | LV_OBJ_FLAG_SCROLLABLE |
                             LV_OBJ_FLAG_SCROLL_ELASTIC | LV_OBJ_FLAG_SCROLL_MOMENTUM); /// Flags
    lv_obj_set_scrollbar_mode(p, LV_SCROLLBAR_MODE_OFF);
    lv_obj_set_style_bg_color(p, lv_color_hex(0x404040), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(p, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_color(p, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_opa(p, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_width(p, 1, LV_PART_MAIN | LV_STATE_DEFAULT);

    lv_obj_t *img = lv_img_create(p);
    setNodeImage(nodeNum, role, img);

    lv_obj_set_width(img, LV_SIZE_CONTENT);
    lv_obj_set_height(img, LV_SIZE_CONTENT);
    lv_obj_set_x(img, -5);
    lv_obj_set_y(img, -10);
    lv_obj_add_flag(img, LV_OBJ_FLAG_ADV_HITTEST);
    lv_obj_clear_flag(img, LV_OBJ_FLAG_SCROLLABLE);
    lv_obj_set_style_radius(img, 4, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(img, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    //    lv_obj_set_style_bg_img_recolor(ui_NodeImage, lv_color_hex(0x4040FF), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_img_recolor_opa(img, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_opa(img, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_width(img, 3, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_img_recolor(img, lv_color_hex(0x202020), LV_PART_MAIN | LV_STATE_DEFAULT);
    //    lv_obj_set_style_img_recolor_opa(ui_NodeImage, 250, LV_PART_MAIN | LV_STATE_DEFAULT);

    lv_obj_t *nodeButton = lv_btn_create(p);
    lv_obj_set_height(nodeButton, 50);
    lv_obj_set_width(nodeButton, lv_pct(50));
    lv_obj_set_x(nodeButton, -13);
    lv_obj_set_y(nodeButton, 0);
    lv_obj_set_align(nodeButton, LV_ALIGN_LEFT_MID);
    lv_obj_add_flag(nodeButton, LV_OBJ_FLAG_SCROLL_ON_FOCUS);
    lv_obj_set_style_bg_color(nodeButton, lv_color_hex(0xFFFFFF), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(nodeButton, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_color(nodeButton, lv_color_hex(0x000000), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_opa(nodeButton, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_width(nodeButton, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_shadow_width(nodeButton, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_shadow_spread(nodeButton, 0, LV_PART_MAIN | LV_STATE_DEFAULT);

    lv_obj_t *ln_lbl = lv_label_create(p);
    lv_obj_set_width(ln_lbl, LV_SIZE_CONTENT);
    lv_obj_set_height(ln_lbl, LV_SIZE_CONTENT);
    lv_obj_set_x(ln_lbl, -5);
    lv_obj_set_y(ln_lbl, 15);
    lv_obj_set_align(ln_lbl, LV_ALIGN_BOTTOM_LEFT);
    lv_label_set_text(ln_lbl, userLong);
    lv_label_set_long_mode(ln_lbl, LV_LABEL_LONG_DOT);
    ln_lbl->user_data = (void *)strlen(userLong);
    lv_obj_set_style_text_color(ln_lbl, lv_color_hex(0xF0F0F0), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_opa(ln_lbl, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ln_lbl, &lv_font_montserrat_12, LV_PART_MAIN | LV_STATE_DEFAULT);

    lv_obj_t *sn_lbl = lv_label_create(p);
    lv_obj_set_width(sn_lbl, LV_SIZE_CONTENT);
    lv_obj_set_height(sn_lbl, LV_SIZE_CONTENT);
    lv_obj_set_x(sn_lbl, 30);
    lv_obj_set_y(sn_lbl, -5);
    lv_obj_set_align(sn_lbl, LV_ALIGN_LEFT_MID);
    lv_label_set_text(sn_lbl, userShort);
    lv_obj_set_style_text_color(sn_lbl, lv_color_hex(0xFFFFFF), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_opa(sn_lbl, 255, LV_PART_MAIN | LV_STATE_DEFAULT);

    lv_obj_t *ui_BatteryLabel = lv_label_create(p);
    lv_obj_set_width(ui_BatteryLabel, LV_SIZE_CONTENT);
    lv_obj_set_height(ui_BatteryLabel, LV_SIZE_CONTENT);
    lv_obj_set_x(ui_BatteryLabel, 8);
    lv_obj_set_y(ui_BatteryLabel, -15);
    lv_obj_set_align(ui_BatteryLabel, LV_ALIGN_RIGHT_MID);
    lv_label_set_text(ui_BatteryLabel, "");
    lv_obj_set_style_text_color(ui_BatteryLabel, lv_color_hex(0xF0F0F0), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_opa(ui_BatteryLabel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_align(ui_BatteryLabel, LV_TEXT_ALIGN_RIGHT, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_BatteryLabel, &lv_font_montserrat_12, LV_PART_MAIN | LV_STATE_DEFAULT);

    lv_obj_t *ui_lastHeardLabel = lv_label_create(p);
    lv_obj_set_width(ui_lastHeardLabel, LV_SIZE_CONTENT);
    lv_obj_set_height(ui_lastHeardLabel, LV_SIZE_CONTENT);
    lv_obj_set_align(ui_lastHeardLabel, LV_ALIGN_RIGHT_MID);
    lv_obj_set_x(ui_lastHeardLabel, 8);
    lv_obj_set_y(ui_lastHeardLabel, 0);

    // TODO: devices without actual time will report all nodes as lastseen = now
    if (lastHeard) {
        time_t curtime;
        time(&curtime);
        lastHeard = std::min(curtime, (time_t)lastHeard); // adapt values too large

        char buf[12];
        bool isOnline = lastHeartToString(lastHeard, buf);
        lv_label_set_text(ui_lastHeardLabel, buf);
        if (isOnline) {
            nodesOnline++;
        }
    } else {
        lv_label_set_text(ui_lastHeardLabel, "");
    }

    lv_obj_set_style_text_color(ui_lastHeardLabel, lv_color_hex(0xF0F0F0), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_opa(ui_lastHeardLabel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_align(ui_lastHeardLabel, LV_TEXT_ALIGN_RIGHT, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_lastHeardLabel, &lv_font_montserrat_12, LV_PART_MAIN | LV_STATE_DEFAULT);
    ui_lastHeardLabel->user_data = (void *)lastHeard;

    lv_obj_t *ui_SignalLabel = lv_label_create(p);
    lv_obj_set_width(ui_SignalLabel, LV_SIZE_CONTENT);
    lv_obj_set_height(ui_SignalLabel, LV_SIZE_CONTENT);
    lv_obj_set_x(ui_SignalLabel, 8);
    lv_obj_set_y(ui_SignalLabel, 12);
    lv_obj_set_align(ui_SignalLabel, LV_ALIGN_BOTTOM_RIGHT);
    lv_label_set_text(ui_SignalLabel, "");
    lv_obj_set_style_text_color(ui_SignalLabel, lv_color_hex(0xFFFFFF), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_opa(ui_SignalLabel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_SignalLabel, &lv_font_montserrat_12, LV_PART_MAIN | LV_STATE_DEFAULT);

    lv_obj_add_event_cb(nodeButton, ui_event_NodeButtonClicked, LV_EVENT_ALL, (void *)nodeNum);

    // move node into new position within nodePanel
    if (lastHeard) {
        lv_obj_t **children = objects.nodes_panel->spec_attr->children;
        int i = objects.nodes_panel->spec_attr->child_cnt - 1;
        while (i > 1) {
            if (lastHeard <= (time_t)(children[i - 1]->LV_OBJ_IDX(node_lh_idx)->user_data))
                break;
            i--;
        }
        if (i >= 1 && i < objects.nodes_panel->spec_attr->child_cnt - 1) {
            lv_obj_move_to_index(p, i);
        }
    }

    updateNodesOnline("%u of %u nodes online");
}

void TFTView_320x240::setMyInfo(uint32_t nodeNum)
{
    ownNode = nodeNum;
    nodes[ownNode] = objects.node_panel;
}

void TFTView_320x240::setDeviceMetaData(int hw_model, const char *version, bool has_bluetooth, bool has_wifi, bool has_eth,
                                        bool can_shutdown)
{
}

void TFTView_320x240::addOrUpdateNode(uint32_t nodeNum, uint8_t ch, const char *userShort, const char *userLong,
                                      uint32_t lastHeard, eRole role)
{
    if (nodes.find(nodeNum) == nodes.end()) {
        addNode(nodeNum, ch, userShort, userLong, lastHeard, role);
    } else {
        updateNode(nodeNum, ch, userShort, userLong, lastHeard, role);
    }
}

/**
 * @brief update node userName and image
 *
 * @param nodeNum
 * @param ch
 * @param userShort
 * @param userLong
 * @param lastHeard
 * @param role
 */
void TFTView_320x240::updateNode(uint32_t nodeNum, uint8_t ch, const char *userShort, const char *userLong, uint32_t lastHeard,
                                 eRole role)
{
    auto it = nodes.find(nodeNum);
    if (it != nodes.end()) {
        lv_label_set_text(it->second->LV_OBJ_IDX(node_lbl_idx), userLong);
        it->second->LV_OBJ_IDX(node_lbl_idx)->user_data = (void *)strlen(userLong);
        lv_label_set_text(it->second->LV_OBJ_IDX(node_lbs_idx), userShort);
        setNodeImage(nodeNum, role, it->second->LV_OBJ_IDX(node_img_idx));
    }
}

void TFTView_320x240::updatePosition(uint32_t nodeNum, int32_t lat, int32_t lon, int32_t alt, uint32_t sats, uint32_t precision)
{
    if (nodeNum == ownNode) {
        char buf[64];
        int latSeconds = (int)round(lat * 1e-7 * 3600);
        int latDegrees = latSeconds / 3600;
        latSeconds = abs(latSeconds % 3600);
        int latMinutes = latSeconds / 60;
        latSeconds %= 60;
        char latLetter = (lat > 0) ? 'N' : 'S';

        int lonSeconds = (int)round(lon * 1e-7 * 3600);
        int lonDegrees = lonSeconds / 3600;
        lonSeconds = abs(lonSeconds % 3600);
        int lonMinutes = lonSeconds / 60;
        lonSeconds %= 60;
        char lonLetter = (lon > 0) ? 'E' : 'W';

        if (sats)
            sprintf(buf, "%c%02i째 %2i'%02i\"   %u sats\n%c%02i째 %2i'%02i\"   %dm", latLetter, abs(latDegrees), latMinutes,
                    latSeconds, sats, lonLetter, abs(lonDegrees), lonMinutes, lonSeconds, abs(alt) < 10000 ? alt : 0);
        else
            sprintf(buf, "%c%02i째 %2i'%02i\"\n%c%02i째 %2i'%02i\"   %dm", latLetter, abs(latDegrees), latMinutes, latSeconds,
                    lonLetter, abs(lonDegrees), lonMinutes, lonSeconds, abs(alt) < 10000 ? alt : 0);

        //        sprintf(buf, "%f\n%f", lat * 1e-7, lon * 1e-7);
        lv_label_set_text(objects.home_location_label, buf);
    }

    auto it = nodes.find(nodeNum);
    if (it != nodes.end()) {
        // TODO
    }
}

/**
 * @brief Update battery level and air utilisation
 *
 * @param nodeNum
 * @param bat_level
 * @param voltage
 * @param chUtil
 * @param airUtil
 */
void TFTView_320x240::updateMetrics(uint32_t nodeNum, uint32_t bat_level, float voltage, float chUtil, float airUtil)
{
    auto it = nodes.find(nodeNum);
    if (it != nodes.end()) {
        char buf[32];
        if (it->first == ownNode) {
            sprintf(buf, "Util %0.1f%% %0.1f%%", chUtil, airUtil);
            lv_label_set_text(it->second->LV_OBJ_IDX(node_sig_idx), buf);

            // update battery percentage and symbol
            if (bat_level != 0 || voltage != 0) {
                uint32_t shown_level = std::min(bat_level, (uint32_t)100);
                sprintf(buf, "%d%%", shown_level);
                lv_label_set_text(objects.battery_percentage_label, buf);
                lv_opa_t recolor = 0;
                uint32_t txtColor = 0xE0E0E0;
                if (bat_level > 100 && voltage > 4.3)
                    lv_img_set_src(objects.battery_image, &img_battery_bolt_image);
                else if (bat_level > 80)
                    lv_img_set_src(objects.battery_image, &img_battery_full_image);
                else if (bat_level > 30)
                    lv_img_set_src(objects.battery_image, &img_battery_mid_image);
                else if (bat_level > 5)
                    lv_img_set_src(objects.battery_image, &img_battery_low_image);
                else if (bat_level > 1) {
                    lv_img_set_src(objects.battery_image, &img_battery_empty_image);
                    recolor = 255;
                    txtColor = 0xF72b2b;
                } else {
                    lv_img_set_src(objects.battery_image, &img_battery_slash_image);
                    recolor = 255;
                    txtColor = 0xF72b2b;
                }
                lv_obj_set_style_img_recolor_opa(objects.battery_image, recolor, LV_PART_MAIN | LV_STATE_DEFAULT);
                lv_obj_set_style_text_color(objects.battery_percentage_label, lv_color_hex(txtColor),
                                            LV_PART_MAIN | LV_STATE_DEFAULT);
            }
        }

        if (bat_level != 0 || voltage != 0) {
            bat_level = std::min(bat_level, (uint32_t)100);
            sprintf(buf, "%d%% %0.2fV", bat_level, voltage);
            lv_label_set_text(it->second->LV_OBJ_IDX(node_bat_idx), buf);
        }
    }
}

void TFTView_320x240::updateSignalStrength(uint32_t nodeNum, int32_t rssi, float snr)
{
    if (nodeNum != ownNode) {
        auto it = nodes.find(nodeNum);
        if (it != nodes.end()) {
            char buf[30];
            if (rssi == 0.0 && snr == 0.0) {
                buf[0] = '\0';
            } else {
                // if userNameLong is too long, skip printing rssi/snr
                if ((size_t)it->second->LV_OBJ_IDX(node_lbl_idx)->user_data <= 20) {
                    sprintf(buf, "rssi: %d snr: %.1f", rssi, snr);
                } else {
                    sprintf(buf, "snr: %.1f", snr);
                }
            }
            lv_label_set_text(it->second->LV_OBJ_IDX(node_sig_idx), buf);
        }
    }
}

void TFTView_320x240::updateConnectionStatus(const meshtastic_DeviceConnectionStatus &status)
{
    if (status.has_wifi) {
        if (status.wifi.has_status) {
            char buf[16];
            uint32_t ip = status.wifi.status.ip_address;
            sprintf(buf, "%d.%d.%d.%d", ip & 0xff000000, ip & 0xff0000, ip & 0xff00, ip & 0xff);
            lv_label_set_text(objects.home_wlan_label, buf);
            if (status.wifi.status.is_connected) {
                lv_obj_set_style_bg_img_recolor_opa(objects.home_wlan_button, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
                lv_obj_set_style_bg_img_src(objects.home_wlan_button, &img_home_wlan_button_image,
                                            LV_PART_MAIN | LV_STATE_DEFAULT);
            } else {
                lv_obj_set_style_bg_img_recolor_opa(objects.home_wlan_button, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
                lv_obj_set_style_bg_img_src(objects.home_wlan_button, &img_home_wlan_button_image,
                                            LV_PART_MAIN | LV_STATE_DEFAULT);
            }
        }
    } else {
        lv_obj_set_style_bg_img_recolor_opa(objects.home_wlan_button, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_obj_set_style_bg_img_src(objects.home_wlan_button, &img_home_wlan_off_image, LV_PART_MAIN | LV_STATE_DEFAULT);
    }
    if (status.has_bluetooth) {
        if (status.bluetooth.is_connected) {
            char buf[16];
            uint32_t mac = ownNode;
            sprintf(buf, "??:??:%02x:%02x:%02x:%02x", mac & 0xff000000, mac & 0xff0000, mac & 0xff00, mac & 0xff);
            lv_label_set_text(objects.home_bluetooth_label, buf);
            lv_obj_set_style_bg_opa(objects.home_bluetooth_button, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
            lv_obj_set_style_bg_img_src(objects.home_bluetooth_button, &img_home_bluetooth_on_button_image,
                                        LV_PART_MAIN | LV_STATE_DEFAULT);
        } else {
            lv_obj_set_style_bg_img_src(objects.home_bluetooth_button, &img_home_bluetooth_on_button_image,
                                        LV_PART_MAIN | LV_STATE_DEFAULT);
            lv_obj_set_style_bg_img_recolor_opa(objects.home_bluetooth_button, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
        }
    } else {
        lv_obj_set_style_bg_img_src(objects.home_bluetooth_button, &img_home_bluetooth_off_button_image,
                                    LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_obj_set_style_bg_img_recolor_opa(objects.home_bluetooth_button, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    }
}

void TFTView_320x240::packetReceived(const meshtastic_MeshPacket &p)
{
    MeshtasticView::packetReceived(p);
}

void TFTView_320x240::notifyResync(bool show)
{
    if (show)
        lv_obj_clear_flag(objects.alert_panel, LV_OBJ_FLAG_HIDDEN);
    else
        lv_obj_add_flag(objects.alert_panel, LV_OBJ_FLAG_HIDDEN);
}

void TFTView_320x240::updateChannelConfig(uint32_t index, const char *name, const uint8_t *psk, uint32_t psk_size, uint8_t role)
{
    static lv_obj_t *btn[c_max_channels] = {objects.channel_button0, objects.channel_button1, objects.channel_button2,
                                            objects.channel_button3, objects.channel_button4, objects.channel_button5,
                                            objects.channel_button6, objects.channel_button7};

    if (strlen(name)) {
        lv_label_set_text(channel[index], name);
        newMessageContainer(0, UINT32_MAX, index);

        lv_obj_set_width(btn[index], lv_pct(70));
        lv_obj_set_style_pad_left(btn[index], 8, LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_obj_t *lockImage = lv_img_create(btn[index]);
        uint32_t recolor = 0;

        if (memcmp(psk, "\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000", 16) == 0) {
            lv_img_set_src(lockImage, &img_groups_key_image);
            recolor = 0xF2E459; // yellow
        } else if (memcmp(psk, "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000", 16) == 0) {
            lv_img_set_src(lockImage, &img_groups_unlock_image);
            recolor = 0xF72B2B; // reddish
        } else {
            lv_img_set_src(lockImage, &img_groups_lock_image);
            recolor = 0x1EC174; // green
        }
        lv_obj_set_width(lockImage, LV_SIZE_CONTENT);  /// 1
        lv_obj_set_height(lockImage, LV_SIZE_CONTENT); /// 1
        lv_obj_set_align(lockImage, LV_ALIGN_LEFT_MID);
        lv_obj_add_flag(lockImage, LV_OBJ_FLAG_ADV_HITTEST);  /// Flags
        lv_obj_clear_flag(lockImage, LV_OBJ_FLAG_SCROLLABLE); /// Flags
        lv_obj_set_style_img_recolor(lockImage, lv_color_hex(recolor), LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_obj_set_style_img_recolor_opa(lockImage, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    } else {
        lv_obj_set_width(btn[index], lv_pct(30));
    }
}

/**
 * @brief Create a new container for a node or group channel
 *
 * @param from
 * @param to: UINT32_MAX for broadcast, ownNode (= us) otherwise
 * @param channel
 */
lv_obj_t *TFTView_320x240::newMessageContainer(uint32_t from, uint32_t to, uint8_t ch)
{
    // create container for new messages
    lv_obj_t *container = lv_obj_create(objects.messages_panel);
    lv_obj_remove_style_all(container);
    lv_obj_set_width(container, lv_pct(110));
    lv_obj_set_height(container, lv_pct(100));
    lv_obj_set_x(container, 0);
    lv_obj_set_y(container, -10);
    lv_obj_set_align(container, LV_ALIGN_TOP_MID);
    lv_obj_set_flex_flow(container, LV_FLEX_FLOW_COLUMN);
    lv_obj_set_flex_align(container, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START);
    lv_obj_clear_flag(container,
                      LV_OBJ_FLAG_PRESS_LOCK | LV_OBJ_FLAG_CLICK_FOCUSABLE | LV_OBJ_FLAG_GESTURE_BUBBLE | LV_OBJ_FLAG_SNAPPABLE |
                          LV_OBJ_FLAG_SCROLL_ELASTIC); /// Flags
    lv_obj_set_scrollbar_mode(container, LV_SCROLLBAR_MODE_ACTIVE);
    lv_obj_set_scroll_dir(container, LV_DIR_VER);
    lv_obj_set_style_pad_left(container, 6, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_right(container, 6, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_top(container, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_bottom(container, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_row(container, 6, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_column(container, 0, LV_PART_MAIN | LV_STATE_DEFAULT);

    // store new message container
    if (to == UINT32_MAX || from == 0) {
        channelGroup[ch] = container;
    } else {
        messages[from] = container;
    }

    // optionally add chat to chatPanel to access the container
    addChat(from, to, ch);

    return container;
}

/**
 * @brief insert a mew message that arrived into a <channel group> or <from node> container
 *
 * @param nodeNum
 * @param ch
 * @param msg
 */
void TFTView_320x240::newMessage(uint32_t from, uint32_t to, uint8_t ch, const char *msg)
{
    // if there's a message from a node we don't know (yet), create it with defaults
    auto it = nodes.find(from);
    if (it == nodes.end()) {
        MeshtasticView::addOrUpdateNode(from, ch, 0, eRole::client);
        updateLastHeard(from);
    }

    char buf[284]; // 237 + 4 + 40 + 2 + 1
    char *message = (char *)msg;
    lv_obj_t *container = nullptr;
    if (to == UINT32_MAX) { // message for group, prepend short name to msg
        sprintf(buf, "%s:\n%s", lv_label_get_text(nodes[from]->LV_OBJ_IDX(node_lbs_idx)), msg);
        message = buf;
        container = channelGroup[ch];
    } else { // message for us
        container = messages[from];
    }

    // if it's the first message we need a container
    if (!container) {
        container = newMessageContainer(from, to, ch);
    }

    // place new message into container
    newMessage(from, container, ch, message);

    // display msg popup if not already viewing the messages
    if (container != activeMsgContainer || activePanel != objects.messages_panel) {
        unreadMessages++;
        updateUnreadMessages();
        if (activePanel != objects.messages_panel) {
            showMessagePopup(from, to, ch, lv_label_get_text(nodes[from]->LV_OBJ_IDX(node_lbl_idx)));
        }
        lv_obj_add_flag(container, LV_OBJ_FLAG_HIDDEN);
    }

    highlightChat(from, to, ch);
}

/**
 * @brief Display message bubble in related message container
 *
 * @param nodeNum
 * @param container
 * @param ch
 * @param msg
 */
void TFTView_320x240::newMessage(uint32_t nodeNum, lv_obj_t *container, uint8_t ch, const char *msg)
{
    lv_obj_t *hiddenPanel = lv_obj_create(container);
    lv_obj_set_width(hiddenPanel, lv_pct(100));
    lv_obj_set_height(hiddenPanel, LV_SIZE_CONTENT); /// 50
    lv_obj_set_align(hiddenPanel, LV_ALIGN_CENTER);
    lv_obj_clear_flag(hiddenPanel, LV_OBJ_FLAG_SCROLLABLE); /// Flags
    lv_obj_set_style_radius(hiddenPanel, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(hiddenPanel, lv_color_hex(0x303030), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(hiddenPanel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_width(hiddenPanel, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_left(hiddenPanel, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_right(hiddenPanel, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_top(hiddenPanel, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_bottom(hiddenPanel, 0, LV_PART_MAIN | LV_STATE_DEFAULT);

    lv_obj_t *msgLabel = lv_label_create(hiddenPanel);
    // calculate expected size of text bubble, to make it look nicer
    lv_coord_t width = lv_txt_get_width(msg, strlen(msg), &lv_font_montserrat_12, 0);
    lv_obj_set_width(msgLabel, std::max(std::min(width + 20, 200), 40));
    lv_obj_set_height(msgLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_align(msgLabel, LV_ALIGN_LEFT_MID);
    lv_label_set_text(msgLabel, msg);
    lv_obj_set_style_text_color(msgLabel, lv_color_hex(0xD0D0D0), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_opa(msgLabel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(msgLabel, &lv_font_montserrat_12, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_radius(msgLabel, 10, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(msgLabel, lv_color_hex(0x404040), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(msgLabel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_color(msgLabel, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_opa(msgLabel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_width(msgLabel, 2, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_left(msgLabel, 8, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_right(msgLabel, 5, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_top(msgLabel, 1, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_bottom(msgLabel, 1, LV_PART_MAIN | LV_STATE_DEFAULT);

    lv_obj_scroll_to_view(hiddenPanel, LV_ANIM_ON);
}

/**
 * @brief Add a new chat to the chat panel to access the message container
 *
 * @param from
 * @param to
 * @param ch
 */
void TFTView_320x240::addChat(uint32_t from, uint32_t to, uint8_t ch)
{
    uint32_t index = ((to == UINT32_MAX || from == 0) ? ch : from);
    auto it = chats.find(index);
    if (it != chats.end())
        return;

    lv_obj_t *chatBtn = lv_btn_create(objects.messages_panel);
    lv_obj_set_height(chatBtn, 30);
    lv_obj_set_width(chatBtn, lv_pct(100));
    lv_obj_set_align(chatBtn, LV_ALIGN_CENTER);
    lv_obj_add_flag(chatBtn, LV_OBJ_FLAG_SCROLL_ON_FOCUS);                                               /// Flags
    lv_obj_clear_flag(chatBtn, LV_OBJ_FLAG_PRESS_LOCK | LV_OBJ_FLAG_SNAPPABLE | LV_OBJ_FLAG_SCROLLABLE); /// Flags
    lv_obj_set_style_radius(chatBtn, 3, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(chatBtn, lv_color_hex(0x404040), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(chatBtn, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_img_recolor(chatBtn, lv_color_hex(0x404040), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_img_recolor_opa(chatBtn, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_color(chatBtn, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_opa(chatBtn, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_width(chatBtn, 1, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_shadow_width(chatBtn, 2, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_shadow_spread(chatBtn, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_shadow_ofs_x(chatBtn, 1, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_shadow_ofs_y(chatBtn, 1, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_left(chatBtn, 3, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_right(chatBtn, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_top(chatBtn, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_bottom(chatBtn, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_row(chatBtn, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_column(chatBtn, 0, LV_PART_MAIN | LV_STATE_DEFAULT);

    char buf[64];
    if (to == UINT32_MAX || from == 0) {
        sprintf(buf, "%d: %s", (int)ch, lv_label_get_text(channel[ch]));
    } else {
        sprintf(buf, "%s: %s", lv_label_get_text(nodes[from]->LV_OBJ_IDX(node_lbs_idx)),
                lv_label_get_text(nodes[from]->LV_OBJ_IDX(node_lbl_idx)));
    }

    lv_obj_t *chatBtnLabel = lv_label_create(chatBtn);
    lv_obj_set_width(chatBtnLabel, 230);
    lv_obj_set_height(chatBtnLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_align(chatBtnLabel, LV_ALIGN_LEFT_MID);
    lv_label_set_long_mode(chatBtnLabel, LV_LABEL_LONG_DOT);
    lv_label_set_text(chatBtnLabel, buf);
    lv_obj_set_style_text_color(chatBtnLabel, lv_color_hex(0xFFFFFF), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_opa(chatBtnLabel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_align(chatBtnLabel, LV_TEXT_ALIGN_LEFT, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(chatBtnLabel, &lv_font_montserrat_12, LV_PART_MAIN | LV_STATE_DEFAULT);

    lv_obj_t *chatDelBtn = lv_btn_create(chatBtn);
    lv_obj_set_width(chatDelBtn, 40);
    lv_obj_set_height(chatDelBtn, 22);
    lv_obj_set_x(chatDelBtn, -3);
    lv_obj_set_y(chatDelBtn, -1);
    lv_obj_set_align(chatDelBtn, LV_ALIGN_RIGHT_MID);
    lv_obj_add_flag(chatDelBtn, LV_OBJ_FLAG_HIDDEN);       /// Flags
    lv_obj_clear_flag(chatDelBtn, LV_OBJ_FLAG_SCROLLABLE); /// Flags
    lv_obj_set_style_bg_color(chatDelBtn, lv_color_hex(0xA70A0A), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(chatDelBtn, 255, LV_PART_MAIN | LV_STATE_DEFAULT);

    lv_obj_t *del_label = lv_label_create(chatDelBtn);
    lv_obj_set_width(del_label, LV_SIZE_CONTENT);  /// 1
    lv_obj_set_height(del_label, LV_SIZE_CONTENT); /// 1
    lv_obj_set_align(del_label, LV_ALIGN_CENTER);
    lv_label_set_text(del_label, "DEL");

    chats[index] = chatBtn;
    updateActiveChats();

    lv_obj_add_event_cb(chatBtn, ui_event_ChatButtonClicked, LV_EVENT_ALL, (void *)index);
    lv_obj_add_event_cb(chatDelBtn, ui_event_ChatDelButtonClicked, LV_EVENT_ALL, (void *)index);
}

void TFTView_320x240::highlightChat(uint32_t from, uint32_t to, uint8_t ch)
{
    uint32_t index = ((to == UINT32_MAX || from == 0) ? ch : from);
    auto it = chats.find(index);
    if (it != chats.end()) {
        // mark chat in color
        lv_obj_set_style_border_color(it->second, lv_color_hex(0xFF8C04), LV_PART_MAIN | LV_STATE_DEFAULT);
    }
}

void TFTView_320x240::updateActiveChats(void)
{
    char buf[20];
    sprintf(buf, "%d active chat(s)", chats.size());
    lv_label_set_text(objects.top_chats_label, buf);
}

/**
 * @brief display new message popup panel
 *
 * @param from sender (NULL for removing popup)
 * @param to individual or group message
 * @param ch received channel
 */
void TFTView_320x240::showMessagePopup(uint32_t from, uint32_t to, uint8_t ch, const char *name)
{
    if (name) {
        static char buf[64];
        sprintf(buf, "New message from \n%s", name);
        buf[38] = '\0'; // cut too long userName
        lv_label_set_text(objects.msg_popup_label, buf);
        if (to == UINT32_MAX)
            objects.msg_popup_button->user_data = (void *)(uint32_t)ch; // store the channel in the button's data
        else
            objects.msg_popup_button->user_data = (void *)from; // store the node in the button's data
        lv_obj_clear_flag(objects.msg_popup_panel, LV_OBJ_FLAG_HIDDEN);
    }
}

void TFTView_320x240::hideMessagePopup(void)
{
    lv_obj_add_flag(objects.msg_popup_panel, LV_OBJ_FLAG_HIDDEN);
}

/**
 * @brief Display messages of a group channel
 *
 * @param ch
 */
void TFTView_320x240::showMessages(uint8_t ch)
{
    lv_obj_add_flag(activeMsgContainer, LV_OBJ_FLAG_HIDDEN);
    activeMsgContainer = channelGroup[ch];
    activeMsgContainer->user_data = (void *)(uint32_t)ch;
    lv_obj_clear_flag(activeMsgContainer, LV_OBJ_FLAG_HIDDEN);
    lv_label_set_text(objects.top_group_chat_label, lv_label_get_text(channel[ch]));
    ui_set_active(objects.messages_button, objects.messages_panel, objects.top_group_chat_panel);
}

/**
 * @brief Display messages from a node
 *
 * @param nodeNum
 */
void TFTView_320x240::showMessages(uint32_t nodeNum)
{
    lv_obj_add_flag(activeMsgContainer, LV_OBJ_FLAG_HIDDEN);
    activeMsgContainer = messages[nodeNum];
    if (!activeMsgContainer) {
        activeMsgContainer = newMessageContainer(nodeNum, 0, 0);
    }
    activeMsgContainer->user_data = (void *)(uint32_t)nodeNum;
    lv_obj_clear_flag(activeMsgContainer, LV_OBJ_FLAG_HIDDEN);
    lv_obj_t *p = nodes[nodeNum];
    if (p) {
        lv_label_set_text(objects.top_messages_node_label, lv_label_get_text(p->LV_OBJ_IDX(node_lbl_idx)));
        ui_set_active(objects.messages_button, objects.messages_panel, objects.top_messages_panel);
        unreadMessages = 0; // TODO: not all messages may be actually read
        updateUnreadMessages();
    } else {
        // TODO: log error
    }
}

// -------- helpers --------

void TFTView_320x240::removeNode(uint32_t nodeNum)
{
    auto it = nodes.find(nodeNum);
    if (it != nodes.end()) {
    }
}

void TFTView_320x240::setNodeImage(uint32_t nodeNum, eRole role, lv_obj_t *img)
{
    uint32_t bgColor, fgColor;
    std::tie(bgColor, fgColor) = nodeColor(nodeNum);
    switch (role) {
    case client:
    case client_mute:
    case client_hidden:
    case tak: {
        lv_img_set_src(img, &img_node_client_image);
        break;
    }
    case router_client: {
        lv_img_set_src(img, &img_top_nodes_image);
        break;
    }
    case repeater:
    case router: {
        lv_img_set_src(img, &img_node_router_image);
        break;
    }
    case tracker:
    case sensor:
    case lost_and_found:
    case tak_tracker: {
        lv_img_set_src(img, &img_node_sensor_image);
        break;
    }
    default:
        lv_img_set_src(img, &img_node_client_image);
        break;
    }

    lv_obj_set_style_bg_color(img, lv_color_hex(bgColor), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_color(img, lv_color_hex(bgColor), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_img_recolor_opa(img, fgColor ? 0 : 255, LV_PART_MAIN | LV_STATE_DEFAULT);
}

void TFTView_320x240::updateNodesOnline(const char *str)
{
    char buf[30];
    sprintf(buf, str, nodesOnline, nodeCount);
    lv_label_set_text(objects.top_nodes_online_label, buf);
    lv_label_set_text(objects.home_nodes_label, buf);
}

/**
 * @brief Update last heard display/user_data/counter to current time
 *
 * @param nodeNum
 */
void TFTView_320x240::updateLastHeard(uint32_t nodeNum)
{
    time_t curtime;
    time(&curtime);
    auto it = nodes.find(nodeNum);
    if (it != nodes.end()) {
        time_t lastHeard = (time_t)it->second->LV_OBJ_IDX(node_lh_idx)->user_data;
        it->second->LV_OBJ_IDX(node_lh_idx)->user_data = (void *)curtime;
        lv_label_set_text(it->second->LV_OBJ_IDX(node_lh_idx), "now");
        if (it->first != ownNode) {
            if (curtime - lastHeard >= 900) {
                nodesOnline++;
                updateNodesOnline("%d of %d nodes online");
            }
            // move to top position
            lv_obj_move_to_index(it->second, 1);
        }
    }
}

/**
 * @brief update last heard display for all nodes; also update nodes online
 *
 */
void TFTView_320x240::updateAllLastHeard(void)
{
    uint16_t online = 0;
    time_t lastHeard;
    for (auto &it : nodes) {
        char buf[20];
        if (it.first == ownNode) { // own node is always now, so do update
            time_t curtime;
            time(&curtime);
            lastHeard = curtime;
            it.second->LV_OBJ_IDX(node_lh_idx)->user_data = (void *)lastHeard;
        } else {
            lastHeard = (time_t)it.second->LV_OBJ_IDX(node_lh_idx)->user_data;
        }
        if (lastHeard) {
            bool isOnline = lastHeartToString(lastHeard, buf);
            lv_label_set_text(it.second->LV_OBJ_IDX(node_lh_idx), buf);
            if (isOnline)
                online++;
        }
    }
    nodesOnline = online;
    updateNodesOnline("%d of %d nodes online");
}

void TFTView_320x240::updateUnreadMessages(void)
{
    char buf[20];
    if (unreadMessages > 0) {
        sprintf(buf, unreadMessages == 1 ? "%d new message" : "%d new messages", unreadMessages);
        lv_obj_set_style_bg_img_src(objects.home_mail_button, &img_home_mail_unread_button_image,
                                    LV_PART_MAIN | LV_STATE_DEFAULT);
    } else {
        strcpy(buf, "no new messages");
        lv_obj_set_style_bg_img_src(objects.home_mail_button, &img_home_mail_button_image, LV_PART_MAIN | LV_STATE_DEFAULT);
    }
    lv_label_set_text(objects.home_mail_label, buf);
}

void TFTView_320x240::updateFreeMem(void)
{
    // only update if HomePanel is active (since this is some critical code that did crash once)
    if (activePanel == objects.home_panel) {
        char buf[64];
        uint32_t freeHeap = 0;
        uint32_t freeHeap_pct = 100;
#ifdef ARDUINO_ARCH_ESP32
        freeHeap = ESP.getFreeHeap();
        freeHeap_pct = 100 * freeHeap / ESP.getHeapSize();
#endif

        lv_mem_monitor_t mon;
        lv_mem_monitor(&mon);
        sprintf(buf, "Heap: %d (%d%%)\nLVGL: %d (%d%%)", freeHeap, freeHeap_pct, mon.free_size, 100 - mon.used_pct);
        lv_label_set_text(objects.home_memory_label, buf);
    }
}

void TFTView_320x240::task_handler(void)
{
    MeshtasticView::task_handler();

    time_t curtime;
    time(&curtime);
    if (curtime - lastrun5 >= 5) { // call every 5s
        lastrun5 = curtime;
        updateFreeMem();
    }
    if (curtime - lastrun60 >= 60) { // call every 60s
        lastrun60 = curtime;
        updateAllLastHeard();
    }
}

// === lvgl C style callbacks ===

extern "C" {

void action_on_boot_screen_displayed(lv_event_t *e)
{
    ILOG_DEBUG("action_on_boot_screen_displayed()\n");
}
}

#endif